"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[9408],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(n),h=i,m=d["".concat(s,".").concat(h)]||d[h]||c[h]||r;return n?a.createElement(m,l(l({ref:t},u),{},{components:n})):a.createElement(m,l({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3919:(e,t,n)=>{function a(e){return!0===/^(\w*:|\/\/)/.test(e)}function i(e){return void 0!==e&&!a(e)}n.d(t,{b:()=>a,Z:()=>i})},4996:(e,t,n)=>{n.d(t,{C:()=>r,Z:()=>l});var a=n(2263),i=n(3919);function r(){const{siteConfig:{baseUrl:e="/",url:t}={}}=(0,a.Z)();return{withBaseUrl:(n,a)=>function(e,t,n,{forcePrependBaseUrl:a=!1,absolute:r=!1}={}){if(!n)return n;if(n.startsWith("#"))return n;if((0,i.b)(n))return n;if(a)return t+n;const l=n.startsWith(t)?n:t+n.replace(/^\//,"");return r?e+l:l}(t,e,n,a)}}function l(e,t={}){const{withBaseUrl:n}=r();return n(e,t)}},8215:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294);const i=function({children:e,hidden:t,className:n}){return a.createElement("div",{role:"tabpanel",hidden:t,className:n},e)}},1395:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(7294),i=n(944),r=n(6010);const l="tabItem_1uMI",o="tabItemActive_2DSg";const s=37,p=39;const u=function(e){const{lazy:t,block:n,defaultValue:u,values:c,groupId:d,className:h}=e,{tabGroupChoices:m,setTabGroupChoices:f}=(0,i.Z)(),[g,k]=(0,a.useState)(u),b=a.Children.toArray(e.children),y=[];if(null!=d){const e=m[d];null!=e&&e!==g&&c.some((t=>t.value===e))&&k(e)}const v=e=>{const t=e.currentTarget,n=y.indexOf(t),a=c[n].value;k(a),null!=d&&(f(d,a),setTimeout((()=>{(function(e){const{top:t,left:n,bottom:a,right:i}=e.getBoundingClientRect(),{innerHeight:r,innerWidth:l}=window;return t>=0&&i<=l&&a<=r&&n>=0})(t)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(o),setTimeout((()=>t.classList.remove(o)),2e3))}),150))},w=e=>{var t;let n;switch(e.keyCode){case p:{const t=y.indexOf(e.target)+1;n=y[t]||y[0];break}case s:{const t=y.indexOf(e.target)-1;n=y[t]||y[y.length-1];break}}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},h)},c.map((({value:e,label:t})=>a.createElement("li",{role:"tab",tabIndex:g===e?0:-1,"aria-selected":g===e,className:(0,r.Z)("tabs__item",l,{"tabs__item--active":g===e}),key:e,ref:e=>y.push(e),onKeyDown:w,onFocus:v,onClick:v},t)))),t?(0,a.cloneElement)(b.filter((e=>e.props.value===g))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},b.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==g})))))}},9443:(e,t,n)=>{n.d(t,{Z:()=>a});const a=(0,n(7294).createContext)(void 0)},944:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294),i=n(9443);const r=function(){const e=(0,a.useContext)(i.Z);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},7840:(e,t,n)=>{n.d(t,{s:()=>i});var a=n(7294);function i({id:e,aspectRatio:t=4/3,hd:n="0"}){return a.createElement("p",{style:{position:"relative",paddingBottom:1/t*100+"%"}},a.createElement("iframe",{src:`https://gfycat.com/ifr/${e}?hd=${n}`,scrolling:"no",frameBorder:"0",allowFullScreen:!0,width:"100%",height:"100%",style:{position:"absolute",top:0,left:0}}))}},8173:(e,t,n)=>{n.d(t,{s:()=>s});var a=n(2177),i=n(8215),r=n(1395),l=n(7294);const o={lua:"Lua",ts:"TypeScript",tsx:"TypeScript",js:"JavaScript",jsx:"JavaScript"};function s({children:e,group:t,titles:n}){(0,a.Z)("string"==typeof t||void 0===t);const s=l.Children.toArray(e).map(((e,t)=>{var a;const i=(null==(a=e.props.children.props.className)?void 0:a.replace(/language-/,""))??`Tab ${t+1}`;return{id:t,languageName:(void 0!==n&&n.length>0?n.split("|"):[])[t]??o[i]??i,element:e}}));return l.createElement(r.Z,{groupId:void 0!==t?`multi-code-block-${t}`:void 0,defaultValue:s[0].id,values:s.map((({id:e,languageName:t})=>({value:e,label:t})))},s.map((({id:e,element:t})=>l.createElement(i.Z,{key:e,value:e},t))))}},6776:(e,t,n)=>{n.d(t,{X:()=>r});var a=n(4996),i=n(7294);function r({path:e,controls:t=!1}){return i.createElement("video",{width:"100%",height:"100%",autoPlay:!0,muted:!0,loop:!0,controls:t},i.createElement("source",{src:(0,a.Z)(e),type:"video/mp4"}))}},8129:(e,t,n)=>{n.d(t,{_:()=>i});var a=n(7294);function i({id:e,playlistId:t,aspectRatio:n=16/9}){const i=void 0!==t?`https://www.youtube.com/embed/videoseries?list=${t}`:`https://www.youtube.com/embed/${e}`;return a.createElement("p",{style:{position:"relative",paddingBottom:1/n*100+"%"}},a.createElement("iframe",{src:i,frameBorder:"0",allowFullScreen:!0,width:"100%",height:"100%",style:{position:"absolute",top:0,left:0}}))}},9385:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>l,metadata:()=>o,toc:()=>s,default:()=>u});var a=n(7462),i=(n(7294),n(3905)),r=(n(1395),n(8215),n(7840));n(8129),n(8173),n(6776);const l={title:"Scripting Introduction",author:"Noya",steamId:"76561198046984233",date:"18.02.2015"},o={unversionedId:"scripting-introduction",id:"scripting-introduction",isDocsHomePage:!1,title:"Scripting Introduction",description:"Part 2 of Getting Started With Dota 2 Modding, this tutorial is meant to explain the basics of programming Dota 2 custom mods.",source:"@site/_articles/scripting-introduction.md",sourceDirName:".",slug:"/scripting-introduction",permalink:"/scripting-introduction",editUrl:"https://github.com/ModDota/moddota.github.io/edit/source/_articles/scripting-introduction.md",version:"current",frontMatter:{title:"Scripting Introduction",author:"Noya",steamId:"76561198046984233",date:"18.02.2015"},sidebar:"tutorials",previous:{title:"Getting Started",permalink:"/getting-started"},next:{title:"Typescript Introduction",permalink:"/scripting/Typescript/typescript-introduction"}},s=[{value:"Scripting",id:"scripting",children:[]},{value:"Lua Scripting",id:"lua-scripting",children:[{value:"Game Logic - Barebones Structure",id:"game-logic---barebones-structure",children:[]},{value:"The Console",id:"the-console",children:[]},{value:"Engine Events",id:"engine-events",children:[]},{value:"Tables.",id:"tables",children:[]}]},{value:"DataDriven RunScript",id:"datadriven-runscript",children:[]},{value:"Scripting Examples and Sources",id:"scripting-examples-and-sources",children:[]}],p={toc:s};function u({components:e,...t}){return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Part 2 of ",(0,i.kt)("a",{parentName:"p",href:"getting-started"},"Getting Started With Dota 2 Modding"),", this tutorial is meant to explain the basics of programming Dota 2 custom mods."),(0,i.kt)("h2",{id:"scripting"},"Scripting"),(0,i.kt)("p",null,"So now you have your freshly created gamemode running and have played around the map editor a bit, it\u2019s time to move into the programming realm of Dota 2 custom maps."),(0,i.kt)("p",null,"Go into your ","<","addonName",">","/scripts/ folder. The 2 main script folders are ",(0,i.kt)("strong",{parentName:"p"},"npc")," and ",(0,i.kt)("strong",{parentName:"p"},"vscripts"),". The first holds the following .txt files:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"npc_",(0,i.kt)("strong",{parentName:"li"},"abilities"),"_custom.txt - Contains all the custom abilities of the gamemode."),(0,i.kt)("li",{parentName:"ul"},"npc_",(0,i.kt)("strong",{parentName:"li"},"heroes"),"_custom.txt - Heroes with its abilities and stats"),(0,i.kt)("li",{parentName:"ul"},"npc_",(0,i.kt)("strong",{parentName:"li"},"items"),"_custom.txt - Items are abilities that go into a units inventory"),(0,i.kt)("li",{parentName:"ul"},"npc_",(0,i.kt)("strong",{parentName:"li"},"units"),"_custom.txt - All the data for non-hero units like buildings or creatures."),(0,i.kt)("li",{parentName:"ul"},"npc_",(0,i.kt)("strong",{parentName:"li"},"abilities"),"_override.txt - Modified dota abilities/items with changed values."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"herolist"),".txt - List of the heroes available for picking.")),(0,i.kt)("p",null,"These files are defined using KeyValues (KV) and are the core of the the ",(0,i.kt)("strong",{parentName:"p"},"DataDriven system"),'. While they fulfill the definition of a programming language, it\u2019s more like a big table containing all the possible data in a static document. it uses a relatively simple syntax whose only special characters are curly braces and quotes, with alternating sets of "Key" and "Value" or "Key" {table} pairs, where table is another set of KeyValues.'),(0,i.kt)("p",null,"KV will define the structure of abilities/items/units, while more elaborate behavior is handled with Lua."),(0,i.kt)("p",null,"Each .txt file contains its particular KVs, and when the game starts, each client (and server) will interpret them. Changes to these files won\u2019t take effect until the game is started again, so be very aware of the syntax, as any extra/missing ",(0,i.kt)("inlineCode",{parentName:"p"},'"')," or ",(0,i.kt)("inlineCode",{parentName:"p"},"{")," ",(0,i.kt)("inlineCode",{parentName:"p"},"}")," will usually make all the keyvalues that come after this error unusable. Consistent ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Indent_style"},"indentation")," is a good practice to learn early! KV is case-sensitive, so also pay attention to write everything like the game expects you to write."),(0,i.kt)("p",null,"Now it\u2019s a good time to get your environment ready to write Dota Scripts. For this, the best way is getting Sublime Text Editor, with these 2 snippet plugins that add completions for some commonly used functions and proper syntax coloring for KV and Lua."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.sublimetext.com/"},"Sublime Text 3")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/bhargavrpatel/dota_kv#installation"},"Sublime Text KeyValues Package")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/bhargavrpatel/Dota-2-Sublime-Packages#installation"},"Sublime Text Lua Package"))),(0,i.kt)("p",null,"This will be just an introductory example to the datadriven system, to understand what goes where and how to expand it."),(0,i.kt)("p",null,"Start a new document in Sublime and make sure you are using Dota KV as the Syntax (press Ctrl+Shift+P and write down Dota KV to select it quickly)."),(0,i.kt)("p",null,'We\u2019ll be making a very simple ability that does single target damage. Start by writing the name of the ability between "" and no spaces. Then write BaseClass... and press Enter to insert the completion. Move through the different fields with Tab.'),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g1Aks/252bb32b2d.png",alt:"img"})),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},'"BaseClass"'),' is essential to every datadriven definition, it orders the game to interpret this ability/item/unit in a certain way- in this case as a datadriven ability. Stock Dota 2 Items, units and heroes have their own base classes which have "hard-coded" behavior that we as modders can\'t change much.'),(0,i.kt)("p",null,"AbilityTextureName can be a custom icon or any internal name of a dota ability, for example lina_laguna_blade."),(0,i.kt)("p",null,"Other essential KV is the AbilityBehavior, write down AbilityB and use the autocomplete"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g1AtQ/cda16f7138.png",alt:"img"})),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g1Avn/65fe86524c.png",alt:"img"})),(0,i.kt)("p",null,"Then we need an ability ",(0,i.kt)("strong",{parentName:"p"},"event"),", this is a trigger for when certain event happens to the owner of the ability. The most basic one is ",(0,i.kt)("inlineCode",{parentName:"p"},"OnSpellStart"),', add one with the completions and you\u2019ll see a new "level" within { } is created, this is known as a block. In ',"[ACTIONS]",', write down a "Damage" action, some keys and a ',(0,i.kt)("inlineCode",{parentName:"p"},"%AbilityDamage")," will appear. A % represents a value to be taken from somewhere else, in this case, an AbilityDamage KV. Add this last key and this first basic spell should be like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"test_ability"\n{\n        "BaseClass"             "ability_datadriven"\n        "AbilityTextureName"    "lina_laguna_blade"\n        "MaxLevel"                      "1"\n\n        "AbilityBehavior"       "DOTA_ABILITY_BEHAVIOR_UNIT_TARGET"\n        "AbilityUnitTargetTeam" "DOTA_UNIT_TARGET_TEAM_ENEMY"\n        "AbilityUnitTargetType" "DOTA_UNIT_TARGET_HERO | DOTA_UNIT_TARGET_BASIC"\n        "AbilityUnitDamageType" "DAMAGE_TYPE_MAGICAL"\n\n        \u201cAbilityDamage\u201d         "500"\n\n        "OnSpellStart"\n        {\n                "Damage"\n                {\n                        "Target"        "TARGET"\n                        "Type"          "DAMAGE_TYPE_MAGICAL"\n                        "Damage"        "%AbilityDamage"\n                }\n        }\n}\n')),(0,i.kt)("p",null,"Now, this ability has to be added to the npc_abilities_custom.txt file for a hero or unit to be able to use it. To do this, you can either edit the file directly, or use multiple files and ",(0,i.kt)("a",{parentName:"p",href:"tools/combining-kv-files-using-base/"},"#base"),"."),(0,i.kt)("p",null,"If editing the file directly, take extra care at the level of brackets you're using. (Sublime Text protip: use Ctrl + ","[ or ]"," to move selected blocks of text left and right through layers of tabs)"),(0,i.kt)("p",null,'Alternatively you can choose to "break" this file in separate files and folders (abilities/items/units/heroes) and then they will combine ',(0,i.kt)("a",{parentName:"p",href:"tools/combining-kv-files-using-base/"},"#base"),". Working with many small key value files is easier to maintain and debug in case of errors."),(0,i.kt)("p",null,'After following this process for the test_ability you just created, it\u2019s time to add the ability to a hero. Open npc_heroes_custom.txt and change the "Ability1" value "example_ability" to "test_ability" (the ability we just made), save and it\u2019s ready to be tested ingame.'),(0,i.kt)("p",null,"Whenever you need a testing dummy, you can create one by writing"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"-createhero (unit_name) enemy")),(0,i.kt)("p",null,"in chat, unit_name being one of the available hero names pickable or just any unit name available. It also accepts shortened names, like \u201cancient\u201d instead of \u201cancient_apparition\u201d. One quick command is ",(0,i.kt)("inlineCode",{parentName:"p"},"-createhero kobold enemy")," which makes a default enemy neutral kobold. The full unit name is \u201cnpc_dota_neutral_kobold\u201d, but the shorter command will do. You can also enable no-cooldown mode by writing ",(0,i.kt)("inlineCode",{parentName:"p"},"-wtf")," (and ",(0,i.kt)("inlineCode",{parentName:"p"},"-unwtf")," will disable it)."),(0,i.kt)("p",null,"Extensive documentation and in-depth examples of the datadriven system can be found in the following links spread over various moddota tutorials."),(0,i.kt)("h2",{id:"lua-scripting"},"Lua Scripting"),(0,i.kt)("p",null,"Going back to the game/scripts folder, there\u2019s the ",(0,i.kt)("strong",{parentName:"p"},"vscripts")," folder. Here is the place where all the Lua scripts are placed. Lua is fairly easy to pick up and its syntax is very straightforward. For the most part, programming in Dota Lua is just knowing which API functions to use (more on this later)."),(0,i.kt)("p",null,"There's 4 applications for Lua in Dota:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Game Logic"),(0,i.kt)("li",{parentName:"ul"},"DataDriven RunScript"),(0,i.kt)("li",{parentName:"ul"},"Hammer I/O"),(0,i.kt)("li",{parentName:"ul"},"Custom UI Events")),(0,i.kt)("h3",{id:"game-logic---barebones-structure"},"Game Logic - Barebones Structure"),(0,i.kt)("p",null,"To understand the core structure of the Dota Lua environment, I\u2019ll be explaining the contents of a simplified Barebones. Go to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/MNoya/barebones/"},"this repository"),", and head to the vscripts folder."),(0,i.kt)("p",null,"In every single gamemode, a file named addon_game_mode.lua must be present. While it is possible to add the game logic to this file (and in fact, valve did so in their holdout example), it is recommended that you reserve this file only for this 3 functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Require"),", here we put all the necessary files that will be used by the game logic, treated as libraries, meaning all the functions inside those files can be used at any point."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Precache"),", when the game starts and players pick their heroes, the engine will try to load the associated models/particles/sounds to those heroes. If we\u2019re dynamically using a resource in Lua before preloading it won\u2019t be displayed properly."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Activate"),", creates the base game mode entity and calls the initialize function.")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g2pUC/ca4413cc48.png",alt:"img"})," ",(0,i.kt)("br",null)," Precache function was folded in sublime"),(0,i.kt)("p",null,"Using our barebones, you don\u2019t need to touch this file apart from very specific situations, and all the core game logic will be coded in gamemode.lua (for older versions it's barebones.lua), which has been already required. We\u2019ll call this your ",(0,i.kt)("em",{parentName:"p"},"main lua file")," from now on."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," For the more advanced starting template you should use our ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/DarkoniusXNG/barebones"},"Barebones"),". Simplified Barebones are specially designed for this tutorial just to explain the essential parts of the Dota Lua structure."),(0,i.kt)("p",null,"After addon_game_mode ",(0,i.kt)("inlineCode",{parentName:"p"},"Precache")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"Activate")," are finished, the first function to be executed in the barebones.lua file is ",(0,i.kt)("inlineCode",{parentName:"p"},"GameMode:InitGameMode()"),"."),(0,i.kt)("p",null,"In here the game starts by initializing all sorts of rules and functions, which are registered over the GameRules and GameMode entities. For this, many variables are defined in settings.lua file to help organizing options like gold settings, kills, custom levels, etc."),(0,i.kt)("p",null,"This is the syntax of a function applied over GameRules, with one bool parameter:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"GameRules:SetHeroRespawnEnabled( ENABLE_HERO_RESPAWN )")),(0,i.kt)("p",null,"Just as KV, Lua is Case Sensitive. Also the placement of the functions within your main Lua file doesn\u2019t generally matter. All the script lines within a function call will be run one after another, potentially on the same ",(0,i.kt)("em",{parentName:"p"},"frame"),"; one frame in Dota is 1/30 of a second."),(0,i.kt)("p",null,"Note the use of ",(0,i.kt)("inlineCode",{parentName:"p"},":")," colon before the function. In Lua, this is how we access the various ",(0,i.kt)("strong",{parentName:"p"},"Game API functions"),". We say that ",(0,i.kt)("inlineCode",{parentName:"p"},"GameRules")," is an ",(0,i.kt)("strong",{parentName:"p"},"HScript")," or a ",(0,i.kt)("strong",{parentName:"p"},"handle"),". Handles are basically huge tables, with all the pertinent info of the entity. Over the ",(0,i.kt)("a",{parentName:"p",href:"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/API"},"Scripting API page")," you\u2019ll see many different types of functions which can use different handles"),(0,i.kt)("p",null,"Global functions don\u2019t need any handle ",(0,i.kt)("inlineCode",{parentName:"p"},":")," prefix. Heroes, Creatures, Abilities and Items all have their different handle classes and attempting to call a function over an incompatible class will cause a VScript error, as pink text in console and red text on the gamescreen."),(0,i.kt)("h3",{id:"the-console"},"The Console"),(0,i.kt)("p",null,"You can access the game console by pressing the ` key."),(0,i.kt)("p",null,"This will provide tons of useful information for debugging. The different colors represent the various \u201cchannels\u201d of information. By default all the channels are in the same Log: Default tab. It\u2019s very recommended that you make your own tabs to split the log viewer."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/y2BUNcS.png",alt:"img"})),(0,i.kt)("p",null,"For Lua Scripting, we want to have a VScript Tab. Messages about the DataDriven system are in the General channel in yellow along with some other info, make a separate viewer for this too."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g2nWY/22554172f6.png",alt:"img"})),(0,i.kt)("p",null,"The new tabs:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g2o1O/b46e113293.png",alt:"img"})),(0,i.kt)("p",null,"The console will notify whenever a Lua scripting error happens, either when the game is being loaded (a syntax-compilation error) or at runtime. In this error, I wrote GameRules.SetHeroRespawnEnabled with ",(0,i.kt)("inlineCode",{parentName:"p"},".")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},":")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g2jo2/6c85128308.png",alt:"img"})),(0,i.kt)("p",null,"You can then trace the error to that line and attempt to solve it, writing ",(0,i.kt)("strong",{parentName:"p"},"script_reload")," in the console to reload the script and check if it was actually fixed."),(0,i.kt)("p",null,"A DataDriven syntax error will usually look like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g3HVp/27ef775669.png",alt:"img"})),(0,i.kt)("h3",{id:"engine-events"},"Engine Events"),(0,i.kt)("p",null,"The second segment of the InitGameMode function is the ",(0,i.kt)("strong",{parentName:"p"},"Listeners"),":"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ListenToGameEvent('dota_player_gained_level', Dynamic_Wrap(GameMode, 'OnPlayerLevelUp'), self)")),(0,i.kt)("p",null,"The structure of this ListenToGameEvent is read as:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Whenever the dota_player_gained_level event is triggered, execute the scripts inside the OnPlayerLevelUp function.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"OnPlayerLevelUp")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"GameMode")," (or ",(0,i.kt)("inlineCode",{parentName:"p"},"barebones")," in updated version) are just the names of the function and main class name we came up with, normally you don\u2019t need to worry about them, all Listeners and functions are already available in barebones, ready to be expanded. ",(0,i.kt)("inlineCode",{parentName:"p"},"Dynamic_Wrap")," is a function to ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"script_reload")," command also reloads the listeners. ",(0,i.kt)("inlineCode",{parentName:"p"},"script_reload")," restarts lua scripts at runtime, unlike DataDriven files which require the game to be fully restarted. As you can see on the barebones example there are tons of possible events, and not all of them are listed there, those are just the most used ones."),(0,i.kt)("p",null,"The 3rd and last part of the ",(0,i.kt)("inlineCode",{parentName:"p"},"InitGameMode")," in simplified Barebones are self defined variables to track info. These use the ",(0,i.kt)("inlineCode",{parentName:"p"},"self.")," entity, which is a local reference to the GameMode entity, seen through all the functions inside the main lua file. Adding information to an entity like ",(0,i.kt)("inlineCode",{parentName:"p"},"entity.")," is loosely called \u201cindexing\u201d and is basically adding another entry to the big table of that entity. This is very useful because this information is stored under the entity handle visible everywhere, and won\u2019t change until we reassign it or destroy it."),(0,i.kt)("p",null,"Enough theory, let\u2019s see how this all comes together. Let's take a look at OnNPCSpawned function, which is the listener for ",(0,i.kt)("inlineCode",{parentName:"p"},"npc_spawned")," and triggers every time a unit or hero entity is added to the map."),(0,i.kt)("p",null,"Let\u2019s analyze the contents of the ",(0,i.kt)("inlineCode",{parentName:"p"},"OnNPCSpawned")," default function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- An NPC has spawned somewhere in game.  This includes heroes\nfunction GameMode:OnNPCSpawned(keys)\n        print("[BAREBONES] NPC Spawned")\n        DeepPrintTable(keys)\n        local npc = EntIndexToHScript(keys.entindex)\n\n        if npc:IsRealHero() and npc.bFirstSpawned == nil then\n                npc.bFirstSpawned = true\n                GameMode:OnHeroInGame(npc)\n        end\nend\n')),(0,i.kt)("p",null,'First line will print the string under "" in the VConsole. The print function is native to Lua, and accepts multiple parameters separated by commas, and concatenation of strings with ',(0,i.kt)("inlineCode",{parentName:"p"},'".."')," like this:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'print("[BAREBONES]".."NPC","Spawned")')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DeepPrintTable")," is a Global Valve-made function which will display the information of the table passed. For keys in this case, it will be the .entindex and .splitscreenplayer. The ",(0,i.kt)("strong",{parentName:"p"},"entity index")," is a very important number to reference the entity. Ignore splitscreenplayer, it\u2019s just legacy source stuff and never used in Dota 2."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g2iLY/54583b0b65.png",alt:"img"})),(0,i.kt)("p",null,"The next line defines a local variable. In Lua local variables have their scope limited to the block where they are declared. It is good programming style to use local variables whenever possible. Local variables help you avoid cluttering the global environment with unnecessary names. Moreover, access to local variables is faster than to global ones."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"local npc = EntIndexToHScript(keys.entindex)")),(0,i.kt)("p",null,"This is basically reading the information that is provided by the event, and storing it into a local variable within that function call. In this example all the Listener and their functions have already been processed, but for reference you can always check the ",(0,i.kt)("a",{parentName:"p",href:"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/Built-In_Engine_Events"},"Built-In_Engine_Events wiki page")," to know exactly what parameters are carried by each event."),(0,i.kt)("p",null,"The npc local variable is an HScript, of handle type. All changes done into the npc variable will reflect on spawned unit."),(0,i.kt)("p",null,"The next line is a conditional, first it checks if the npc is a real hero (this excludes illusions) and it also checks if the .bFirstSpawned index (a self-defined variable) has not been assigned yet. If both conditions are true, changes the boolean value to true and calls the OnHeroInGame function."),(0,i.kt)("p",null,"To finish this basic Dota Lua tutorial, let\u2019s modify the OnNPCSpawned function so that if a unit named npc_dota_neutral_kobold is spawned, wait 1 seconds and then kill itself. Added to the first if statement there\u2019s this else-if condition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'function GameMode:OnNPCSpawned(keys)\n   local npc = EntIndexToHScript(keys.entindex)\n\n   if npc:IsRealHero() and npc.bFirstSpawned == nil then\n       npc.bFirstSpawned = true\n       GameMode:OnHeroInGame(npc)\n   elseif npc:GetUnitName() == "npc_dota_neutral_kobold" then\n       Timers:CreateTimer( 1.0 , function()\n           npc:ForceKill(true)\n       end)\n    end\nend\n')),(0,i.kt)("p",null,"Here we make use of the Timers library for a simple 1.0 second delay, there are many different timer functions included and explained in timers.lua. The bool on ForceKill is to enable the death animation."),(0,i.kt)(r.s,{id:"DigitalDefinitiveChimpanzee",mdxType:"Gfycat"}),(0,i.kt)("h3",{id:"tables"},"Tables."),(0,i.kt)("p",null,"Tables are the most important structure we will have to use. As mentioned before, all the info on entities can be seen as a table (even though it's technically a pointer to a C++ object), and you Get and Set the values through the various Game API functions."),(0,i.kt)("p",null,"There are some functions in the API that return a table of entity handles."),(0,i.kt)("p",null,"Let say you want to find all the units near the spawned kobold unit and kill them. The function ",(0,i.kt)("inlineCode",{parentName:"p"},"FindUnitsInRadius")," can be used for this purpose, and takes a lot of parameters with different types which is worth explaining:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"table FindUnitsInRadius(int teamNumber, Vector position, handle cacheUnit, float radius, int teamFilter, int typeFilter, int flagFilter, int order, bool canGrowCache)")),(0,i.kt)("p",null,"The parameters Have to be in this order. This function is a global, so no ",(0,i.kt)("inlineCode",{parentName:"p"},"handle:")," needed, but we need to keep the table under a variable, like this:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"local units = FindUnitsInRadius(...)")),(0,i.kt)("p",null,"For the teamNumber, finding out which team an entity is in can be done with ",(0,i.kt)("inlineCode",{parentName:"p"},"GetTeamNumber()")," on the npc handle. As for the other Filter parameters, instead of real integers, we use a bunch of ",(0,i.kt)("strong",{parentName:"p"},"Constants")," that represent different number values. The complete list of Constants is ",(0,i.kt)("a",{parentName:"p",href:"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/Constants"},"found on this wiki page"),"."),(0,i.kt)("p",null,"A Vector is represented as Vector(x,y,z) coordinates. The function to get the position of  particular unit is called ",(0,i.kt)("inlineCode",{parentName:"p"},"GetAbsOrigin")," and takes a npc handle."),(0,i.kt)("p",null,"As for the cache parameters, just leave it nil and false, they aren't of much use generally."),(0,i.kt)("p",null,"The complete function call to get the heroes in 500 radius from the spawned kobold would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"local units = FindUnitsInRadius( npc:GetTeamNumber(), npc:GetAbsOrigin(), nil, 500,\n                                 DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO,\n                                    DOTA_UNIT_TARGET_FLAG_NONE, FIND_ANY_ORDER, false)\n")),(0,i.kt)("p",null,"The use of extra break lines is just to make it more readable. Now we want to ",(0,i.kt)("strong",{parentName:"p"},"iterate over the entities of this table"),", which is done like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"for key, unit in pairs(units) do\n    print(key, value)\n    unit:ForceKill(true)\nend\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," are the chosen names to refer to the position and value inside the ",(0,i.kt)("em",{parentName:"p"},"units")," table, which will be read in pairs. Using ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," as the name of the key is a good convention when you want to make it clear that the first parameter won't be used. The 2nd parameter, unit, is used to iterate handles of the units found."),(0,i.kt)("p",null,'There is one more thing to consider: the "wait one frame" issue. Because all units are actually spawned at the (0,0,0) coordinates and then moved to the desired position, many times you\'ll need to create a 0.03 second timer (1 frame on the server) for some scripts to work, and this is one of those cases.'),(0,i.kt)("p",null,"So, ",(0,i.kt)("inlineCode",{parentName:"p"},"OnNPCSpawned")," is looking like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'function GameMode:OnNPCSpawned(keys)\n   local npc = EntIndexToHScript(keys.entindex)\n\n   if npc:IsRealHero() and npc.bFirstSpawned == nil then\n      npc.bFirstSpawned = true\n      GameMode:OnHeroInGame(npc)\n   elseif npc:GetUnitName() == "npc_dota_neutral_kobold" then\n      Timers:CreateTimer(0.03, function()\n        local units = FindUnitsInRadius( npc:GetTeamNumber(), npc:GetAbsOrigin(), nil, 500,\n                      DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_HERO,\n                      DOTA_UNIT_TARGET_FLAG_NONE, FIND_ANY_ORDER, false)\n\n        for key, value in pairs(units) do\n          print(key, value)\n          value:ForceKill(true)\n        end\n      end)\n   end\nend\n')),(0,i.kt)("p",null,"And the result ingame:"),(0,i.kt)(r.s,{id:"SkeletalIcyDalmatian",mdxType:"Gfycat"}),(0,i.kt)("h2",{id:"datadriven-runscript"},"DataDriven RunScript"),(0,i.kt)("p",null,"The 2nd application for Lua in Dota 2 Modding is the ",(0,i.kt)("inlineCode",{parentName:"p"},'"RunScript"')," Action, which can be called from any DataDriven Event to connect the ability or item with with a Lua Script File"),(0,i.kt)("p",null,"RunScript creates a new instance of the lua file, so .globals don\u2019t really apply here, all variables should be either local and/or assigned to a handle."),(0,i.kt)("p",null,"Splitting the lua files for each ability is a good idea as it also helps splitting the ability scripts just like with the txt files"),(0,i.kt)("p",null,"Let\u2019s go back to the first super simple single target damage datadriven ability and add this block to the OnSpellStart ability event:"),(0,i.kt)("p",null,"The Syntax is like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g2x6h/d16e2db05b.png",alt:"img"})),(0,i.kt)("p",null,"ScriptFile route is relative to the /vscripts/ folder. AbilityName is the name of the lua function inside that file."),(0,i.kt)("p",null,"Let's go back to the ",(0,i.kt)("a",{parentName:"p",href:"##basicability"},"super basic datadriven ability")," and add a RunScript block for a ScriptFile in a subfolder. Unlike the general Game Logic, it's recommended to separate the lua files for each ability script, and in different folders to separate heroes, units, items, etc. At the end, organization is up to you."),(0,i.kt)("p",null,"Adding this block to a DD Event like OnSpellStart will make a new instance of the example_script and execute the lines defined in function ScriptedAbility."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"RunScript"\n{\n    "ScriptFile"    "heroes/example_script.lua"\n    "Function"      "ScriptedAbility"\n}\n')),(0,i.kt)("p",null,"In your vscripts folder, make a heroes folder and a example_script file with a .lua extension. I recommend setting these files to automatically open with Sublime, and set the syntax to Dota Lua."),(0,i.kt)("p",null,"In this example script, the event will pass some information to the first parameter of the functions, which can have any name but you'll see most refer to this parameter as ",(0,i.kt)("inlineCode",{parentName:"p"},"keys")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"event"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g2y9i/dfb5db78c9.png",alt:"img"})),(0,i.kt)("p",null,"In the body, most ability scripts start by defining the local variables for the target entities which are passed by the event. This is explained more deeply in the guide ",(0,i.kt)("a",{parentName:"p",href:"abilities/datadriven/all-about-the-target"},"All About The Target"),", but the basic target variables visible on any script are"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},".caster"),", the entity that started the ability."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},".target"),", the target of the ability (can be same as the caster in some cases)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},".ability"),", ability itself.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"function ScriptedAbility( event )\n    local caster = event.caster\n    local target = event.target\n    local ability = event.ability\n\n    if target:GetHealthPercent() < 50 then\n        target:Kill(ability, caster) -- Kills this NPC, with the params Ability and Attacker\n    end\nend\n")),(0,i.kt)("p",null,"This will kill the targeted unit if its Health percent is less than half, and credits the kill to the caster entity."),(0,i.kt)("h2",{id:"scripting-examples-and-sources"},"Scripting Examples and Sources"),(0,i.kt)("p",null,"There are plenty of examples spread all across GitHub and with the contents of this guide you should now be able to understand the scripting flow of game logic and scripted abilities.\nThe best GitHub repo to look for ability-datadriven spells is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Pizzalol/SpellLibrary"},"SpellLibrary")," and for ability_lua spells is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Elfansoer/dota-2-lua-abilities"},"Elfansoer's library"),"."),(0,i.kt)("p",null,"If you want to check the scripts of a certain game on the ",(0,i.kt)("a",{parentName:"p",href:"https://steamcommunity.com/workshop/browse/?appid=570&browsesort=trend&section=readytouseitems"},"Custom Games Workshop")," which hasn't made their source public on GitHub (because they are fools), just follow these steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Subscribe to the game. Download ",(0,i.kt)("a",{parentName:"li",href:"https://developer.valvesoftware.com/wiki/GCFScape"},"GCFScape")," or ",(0,i.kt)("a",{parentName:"li",href:"https://vrf.steamdb.info/"},"Valve Resource Viewer")," if you haven't done so yet."),(0,i.kt)("li",{parentName:"ol"},"Check the URL, steamcommunity.com/sharedfiles/filedetails/?id=",(0,i.kt)("strong",{parentName:"li"},"copy this number")),(0,i.kt)("li",{parentName:"ol"},"Go to your Steam folder -> SteamApps -> workshop -> content -> 570 (this is the dota folder)"),(0,i.kt)("li",{parentName:"ol"},"Search for the copied number folder"),(0,i.kt)("li",{parentName:"ol"},"Open the .vpk file with GCFScape or VRF and extract its contents anywhere you want. Now you can access its scripts and compiled models/particles/sounds.")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g2zNP/d1e018010e.png",alt:"img"})),(0,i.kt)("p",null,"Whenever you have a doubt about how to use a particular GameAPI function, its possible to find examples all over GitHub by just writing the name of it, additionally filtering by lua like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://puu.sh/g2yTG/93f1641866.png",alt:"img"})),(0,i.kt)("p",null,"Just make sure it's actually Dota Lua and not another game API, as some of the functions might share names with other engines."),(0,i.kt)("p",null,"That's all for the Scripting basics. I expect you to have more questions than when you started reading, feel free to drop all your doubts at the community's ",(0,i.kt)("a",{parentName:"p",href:"https://discord.com/invite/tPvHaRz"},"Discord channel"),", you'll find help there 24/7."),(0,i.kt)("hr",null))}u.isMDXComponent=!0},6010:(e,t,n)=>{function a(e){var t,n,i="";if("string"==typeof e||"number"==typeof e)i+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(i&&(i+=" "),i+=n);else for(t in e)e[t]&&(i&&(i+=" "),i+=t);return i}function i(){for(var e,t,n=0,i="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(i&&(i+=" "),i+=t);return i}n.d(t,{Z:()=>i})}}]);