"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[7050],{3905:(e,t,i)=>{i.d(t,{Zo:()=>p,kt:()=>m});var n=i(7294);function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){o(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function l(e,t){if(null==e)return{};var i,n,o=function(e,t){if(null==e)return{};var i,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(o[i]=e[i]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(o[i]=e[i])}return o}var c=n.createContext({}),s=function(e){var t=n.useContext(c),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},p=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var i=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=s(i),m=o,u=h["".concat(c,".").concat(m)]||h[m]||d[m]||a;return i?n.createElement(u,r(r({ref:t},p),{},{components:i})):n.createElement(u,r({ref:t},p))}));function m(e,t){var i=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=i.length,r=new Array(a);r[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var s=2;s<a;s++)r[s]=i[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,i)}h.displayName="MDXCreateElement"},3919:(e,t,i)=>{function n(e){return!0===/^(\w*:|\/\/)/.test(e)}function o(e){return void 0!==e&&!n(e)}i.d(t,{b:()=>n,Z:()=>o})},4996:(e,t,i)=>{i.d(t,{C:()=>a,Z:()=>r});var n=i(2263),o=i(3919);function a(){const{siteConfig:{baseUrl:e="/",url:t}={}}=(0,n.Z)();return{withBaseUrl:(i,n)=>function(e,t,i,{forcePrependBaseUrl:n=!1,absolute:a=!1}={}){if(!i)return i;if(i.startsWith("#"))return i;if((0,o.b)(i))return i;if(n)return t+i;const r=i.startsWith(t)?i:t+i.replace(/^\//,"");return a?e+r:r}(t,e,i,n)}}function r(e,t={}){const{withBaseUrl:i}=a();return i(e,t)}},8215:(e,t,i)=>{i.d(t,{Z:()=>o});var n=i(7294);const o=function({children:e,hidden:t,className:i}){return n.createElement("div",{role:"tabpanel",hidden:t,className:i},e)}},1395:(e,t,i)=>{i.d(t,{Z:()=>p});var n=i(7294),o=i(944),a=i(6010);const r="tabItem_1uMI",l="tabItemActive_2DSg";const c=37,s=39;const p=function(e){const{lazy:t,block:i,defaultValue:p,values:d,groupId:h,className:m}=e,{tabGroupChoices:u,setTabGroupChoices:v}=(0,o.Z)(),[g,f]=(0,n.useState)(p),k=n.Children.toArray(e.children),w=[];if(null!=h){const e=u[h];null!=e&&e!==g&&d.some((t=>t.value===e))&&f(e)}const y=e=>{const t=e.currentTarget,i=w.indexOf(t),n=d[i].value;f(n),null!=h&&(v(h,n),setTimeout((()=>{(function(e){const{top:t,left:i,bottom:n,right:o}=e.getBoundingClientRect(),{innerHeight:a,innerWidth:r}=window;return t>=0&&o<=r&&n<=a&&i>=0})(t)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(l),setTimeout((()=>t.classList.remove(l)),2e3))}),150))},N=e=>{var t;let i;switch(e.keyCode){case s:{const t=w.indexOf(e.target)+1;i=w[t]||w[0];break}case c:{const t=w.indexOf(e.target)-1;i=w[t]||w[w.length-1];break}}null==(t=i)||t.focus()};return n.createElement("div",{className:"tabs-container"},n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":i},m)},d.map((({value:e,label:t})=>n.createElement("li",{role:"tab",tabIndex:g===e?0:-1,"aria-selected":g===e,className:(0,a.Z)("tabs__item",r,{"tabs__item--active":g===e}),key:e,ref:e=>w.push(e),onKeyDown:N,onFocus:y,onClick:y},t)))),t?(0,n.cloneElement)(k.filter((e=>e.props.value===g))[0],{className:"margin-vert--md"}):n.createElement("div",{className:"margin-vert--md"},k.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==g})))))}},9443:(e,t,i)=>{i.d(t,{Z:()=>n});const n=(0,i(7294).createContext)(void 0)},944:(e,t,i)=>{i.d(t,{Z:()=>a});var n=i(7294),o=i(9443);const a=function(){const e=(0,n.useContext)(o.Z);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},7840:(e,t,i)=>{i.d(t,{s:()=>o});var n=i(7294);function o({id:e,aspectRatio:t=4/3,hd:i="0"}){return n.createElement("p",{style:{position:"relative",paddingBottom:1/t*100+"%"}},n.createElement("iframe",{src:`https://gfycat.com/ifr/${e}?hd=${i}`,scrolling:"no",frameBorder:"0",allowFullScreen:!0,width:"100%",height:"100%",style:{position:"absolute",top:0,left:0}}))}},8173:(e,t,i)=>{i.d(t,{s:()=>c});var n=i(2177),o=i(8215),a=i(1395),r=i(7294);const l={lua:"Lua",ts:"TypeScript",tsx:"TypeScript",js:"JavaScript",jsx:"JavaScript"};function c({children:e,group:t,titles:i}){(0,n.Z)("string"==typeof t||void 0===t);const c=r.Children.toArray(e).map(((e,t)=>{var n;const o=(null==(n=e.props.children.props.className)?void 0:n.replace(/language-/,""))??`Tab ${t+1}`;return{id:t,languageName:(void 0!==i&&i.length>0?i.split("|"):[])[t]??l[o]??o,element:e}}));return r.createElement(a.Z,{groupId:void 0!==t?`multi-code-block-${t}`:void 0,defaultValue:c[0].id,values:c.map((({id:e,languageName:t})=>({value:e,label:t})))},c.map((({id:e,element:t})=>r.createElement(o.Z,{key:e,value:e},t))))}},6776:(e,t,i)=>{i.d(t,{X:()=>a});var n=i(4996),o=i(7294);function a({path:e,controls:t=!1}){return o.createElement("video",{width:"100%",height:"100%",autoPlay:!0,muted:!0,loop:!0,controls:t},o.createElement("source",{src:(0,n.Z)(e),type:"video/mp4"}))}},8129:(e,t,i)=>{i.d(t,{_:()=>o});var n=i(7294);function o({id:e,playlistId:t,aspectRatio:i=16/9}){const o=void 0!==t?`https://www.youtube.com/embed/videoseries?list=${t}`:`https://www.youtube.com/embed/${e}`;return n.createElement("p",{style:{position:"relative",paddingBottom:1/i*100+"%"}},n.createElement("iframe",{src:o,frameBorder:"0",allowFullScreen:!0,width:"100%",height:"100%",style:{position:"absolute",top:0,left:0}}))}},311:(e,t,i)=>{i.r(t),i.d(t,{frontMatter:()=>r,metadata:()=>l,toc:()=>c,default:()=>p});var n=i(7462),o=(i(7294),i(3905)),a=(i(1395),i(8215),i(7840),i(8129),i(8173));i(6776);const r={title:"Basic Vector Math",author:"Perry",steamId:"76561198046986723",date:"01.10.2020"},l={unversionedId:"scripting/vector-math",id:"scripting/vector-math",isDocsHomePage:!1,title:"Basic Vector Math",description:"While creating games it is hard to avoid using vector math, however they are not commonly taught in schools. While they are fairly intuitive once you get used to them, learning about vector math for the first time can be a bit difficult, therefore this tutorial.",source:"@site/_articles/scripting/vector-math.md",sourceDirName:"scripting",slug:"/scripting/vector-math",permalink:"/scripting/vector-math",editUrl:"https://github.com/ModDota/moddota.github.io/edit/source/_articles/scripting/vector-math.md",version:"current",frontMatter:{title:"Basic Vector Math",author:"Perry",steamId:"76561198046986723",date:"01.10.2020"},sidebar:"tutorials",previous:{title:"Particle Attachment",permalink:"/scripting/particle-attachment"},next:{title:"Precache, Fixing and avoiding issues",permalink:"/scripting/precache-fixing-and-avoiding-issues"}},c=[{value:"Introduction to vectors",id:"introduction-to-vectors",children:[{value:"What is a vector",id:"what-is-a-vector",children:[]},{value:"Adding vectors",id:"adding-vectors",children:[]},{value:"Subtracting vectors",id:"subtracting-vectors",children:[]},{value:"Multiplying vectors",id:"multiplying-vectors",children:[]},{value:"Vectors as Direction/Orientation",id:"vectors-as-directionorientation",children:[]},{value:"Dot product",id:"dot-product",children:[]},{value:"Normalization",id:"normalization",children:[]}]},{value:"Vector math in games",id:"vector-math-in-games",children:[{value:"Spawning an item in front of the player",id:"spawning-an-item-in-front-of-the-player",children:[]},{value:"Checking if unit is facing a direction",id:"checking-if-unit-is-facing-a-direction",children:[]},{value:"Checking if unit is attacked from behind",id:"checking-if-unit-is-attacked-from-behind",children:[]},{value:"Creating some effects around player",id:"creating-some-effects-around-player",children:[]},{value:"Physics with vectors - Homing projectile",id:"physics-with-vectors---homing-projectile",children:[]}]}],s={toc:c};function p({components:e,...t}){return(0,o.kt)("wrapper",(0,n.Z)({},s,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"While creating games it is hard to avoid using vector math, however they are not commonly taught in schools. While they are fairly intuitive once you get used to them, learning about vector math for the first time can be a bit difficult, therefore this tutorial."),(0,o.kt)("h2",{id:"introduction-to-vectors"},"Introduction to vectors"),(0,o.kt)("h3",{id:"what-is-a-vector"},"What is a vector"),(0,o.kt)("p",null,"Vectors are a way to describe a point or direction in space. This space can have any number of dimensions, but for this tutorial we will focus on 2D just because it is easier to draw. All of these concepts also apply to higher dimension vectors though!"),(0,o.kt)("p",null,"Usually a vector will be represented as ",(0,o.kt)("inlineCode",{parentName:"p"},"(x, y)"),", which you can either interpret as:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Point with coordinates (x, y)")),(0,o.kt)("p",null,"or"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Movement from (0, 0) to point (x, y)")),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"When using vectors as a movement they only describe a movement TO somewhere, originating from the origin (0, 0). If you want to describe a movement that also has a FROM part, you need a second vector to describe the initial position."))),(0,o.kt)("h4",{id:"example"},"Example"),(0,o.kt)("p",null,"So let's look at how we would think about and vizualize two vectors: ",(0,o.kt)("inlineCode",{parentName:"p"},"A: (3, 2)")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B: (-1, 3)"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/4lalG0u.png",alt:"Vector vizualization"})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," vectors have no origin and always originate from (0, 0). If you consider vectors as movements from origin to a point, you can also calculate their length, denoted by l_A and l_B."),(0,o.kt)("h3",{id:"adding-vectors"},"Adding vectors"),(0,o.kt)("p",null,"So let's say you consider vectors as movements, you can simply add two vectors to get the result of doing both movements. For example if you have a vector ",(0,o.kt)("inlineCode",{parentName:"p"},"A (xa, ya)")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B (xb, yb)")," indicating two movements, what is the result of doing both ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),"? This is visualized like so:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/YBzf6oO.png",alt:"Vector addition"})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," Moving by vector A first and then by B will result in the same vector as moving by B first followed by A. (This is why visualizing vector addition always results in this parallelogram)."),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Example")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"You can use calculate things like offsets or knockbacks using addition, i.e where does a unit end after getting knocked back in some direction?"),(0,o.kt)("pre",{parentName:"div"},(0,o.kt)("code",{parentName:"pre"},"newUnitPos = unitPos + knockbackVector\n")))),(0,o.kt)("h3",{id:"subtracting-vectors"},"Subtracting vectors"),(0,o.kt)("p",null,"Now let's say we want to know the inverse question to the previous one: Assuming I have two vector positions ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),", what movement do I have to do to get from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),"? The answer to this is a vector subtraction: ",(0,o.kt)("inlineCode",{parentName:"p"},"C = B - A"),". Note that this works exactly like regular math, so doing ",(0,o.kt)("inlineCode",{parentName:"p"},"A + C = B"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/Sa4gnxz.png",alt:"Vector subtraction"})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," Just like when subtracting regular numbers, order matters! ",(0,o.kt)("inlineCode",{parentName:"p"},"B - A")," gives the vector from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),", while ",(0,o.kt)("inlineCode",{parentName:"p"},"A - B")," gives the opposite vector, from ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Example")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"You can use vector subtraction to calculate the difference in position between two units, and get for example the distance between them:"),(0,o.kt)("pre",{parentName:"div"},(0,o.kt)("code",{parentName:"pre"},"distanceBetweenUnit1AndUnit2 = length(unit2Pos - unit1Pos)\n")))),(0,o.kt)("h3",{id:"multiplying-vectors"},"Multiplying vectors"),(0,o.kt)("p",null,"The last 'basic' vector operation I want to go over is multiplication with a number (NOT with another vector)."),(0,o.kt)("p",null,"When multiplying a vector with a number it retains its direction, but its length is multiplied by this number:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/1h83sJr.png",alt:"Vector multiplication"})),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Example")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"You can use vector multiplication to rescale vectors to a certain length. For example when you have a unit or normal vector (length 1), multiplying with a number will make it that length."),(0,o.kt)("pre",{parentName:"div"},(0,o.kt)("code",{parentName:"pre"},"vectorOfLength100 = vectorOfLength1 * 100\n")))),(0,o.kt)("h3",{id:"vectors-as-directionorientation"},"Vectors as Direction/Orientation"),(0,o.kt)("p",null,"As seen before, vectors look very much like a direction to somewhere. This makes them very useful for representing the orientation of something instead of using an angle (because angles make calculating much more difficult)."),(0,o.kt)("p",null,"To do so, orientation is often expressed as vectors of length 1. This is because of the special relation vectors have with angles: For an angle ",(0,o.kt)("inlineCode",{parentName:"p"},"a"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"(cos(a), sin(a))")," is a vector of length 1, pointing in the direction of angle ",(0,o.kt)("inlineCode",{parentName:"p"},"a"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/vjW0ye7.png",alt:"Vectors and angles"})),(0,o.kt)("p",null,"You might be wondering what the point of this is, for an application if why storing orientation as vectors of length 1 see section 'Spawning an item in front of the player'."),(0,o.kt)("h3",{id:"dot-product"},"Dot product"),(0,o.kt)("p",null,"The final vector concept for this tutorial is the 'dot product' of two vectors. Simply put, this dot product gives you a measure of 'how much vectors are pointing in the same direction'. If two vectors (of length 1) point in exactly the same direction, the dot product is 1. If two vectors (of length 1) point in exactly the opposite direction the dot product is -1. If the two vectors are at a 90 degree angle, the dot product is 0:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/erBE2yl.png",alt:"Dot product"})),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Technically ",(0,o.kt)("inlineCode",{parentName:"p"},"dot(A, B) = length(A) * length(B) * cos(angle)"),", so watch out when calculating the dot product of non-length-1 vectors: they will no longer range from -1 to 1."))),(0,o.kt)("h3",{id:"normalization"},"Normalization"),(0,o.kt)("p",null,"As mentioned shown above it is often very useful to have vectors of length 1 (only the direction, not the distance). This is so common there is a standard procedure to calculate this: Normalization. When normalizing a vector you simply divide it by its length (or multiply with 1/length). This will always give you a vector of length 1."),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Vectors with length 1 are referred to as 'Normal' or 'Unit' vectors."))),(0,o.kt)("h2",{id:"vector-math-in-games"},"Vector math in games"),(0,o.kt)("h3",{id:"spawning-an-item-in-front-of-the-player"},"Spawning an item in front of the player"),(0,o.kt)("p",null,"Let's say we want to spawn an item 100 units in front of a player hero, how do we calculate this location ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),"?"),(0,o.kt)("p",null,"We can visualize this question like this:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/1ksId50.png",alt:"Spawning in front of a player"})),(0,o.kt)("p",null,"Referencing this visualization it is obvious we can calculate this A as follows:"),(0,o.kt)(a.s,{group:"vscripts",mdxType:"MultiCodeBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"-- Calculate the vector from the hero to the point by multiplying\n-- their forward vector (length 1) with the desired distance.\nlocal heroToPoint = hero:GetForwardVector() * 100\n-- Calculate world position  of the item by adding the vector\n-- from hero to point to the world position of the hero\nlocal itemPos = hero:GetAbsOrigin() + heroToPoint\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// Calculate the vector from the hero to the point by multiplying\n// their forward vector (length 1) with the desired distance.\nconst heroToPoint = (hero.GetForwardVector() * 100) as Vector;\n// Calculate world position  of the item by adding the vector\n// from hero to point to the world position of the hero\nconst itemPos = (hero.GetAbsOrigin() + heroToPoint) as Vector;\n"))),(0,o.kt)("h3",{id:"checking-if-unit-is-facing-a-direction"},"Checking if unit is facing a direction"),(0,o.kt)("p",null,"Another common question is how can we calculate if my unit is facing a specific point on the map."),(0,o.kt)("p",null,"We visualize this problem like this:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/iBH3cIk.png",alt:"Facing point?"})),(0,o.kt)("p",null,"So looking at the visualization, when does a unit face point P? Well it looks like this happens when their forward vector (the orange one) aligns with the vector from the unit to the point (the purple one). So capturing this in code would look a little like this:"),(0,o.kt)(a.s,{group:"vscripts",mdxType:"MultiCodeBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"function isUnitFacingPoint(unit, point)\n  -- Calculate the relative position of the unit to the point\n  local relativePosition = point - unit:GetAbsOrigin()\n  -- Remember, using dot product works best with normal vectors\n  -- The unit's forward is already normal, but we need to normalize\n  -- the relative position to only get its direction.\n  local directionToPoint = relativePosition:Normalized()\n\n  -- Check if the alignment of the forward vector and relative direction\n  -- is within some acceptable range of tolerance\n  return unit:GetForwardVector():Dot(directionToPoint) > 0.7\nend\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"function isUnitFacingPoint(unit: CDOTA_BaseNPC, point: Vector): boolean {\n  // Calculate the relative position of the unit to the point\n  const relativePosition = (point - unit.GetAbsOrigin()) as Vector;\n  // Remember, using dot product works best with normal vectors\n  // The unit's forward is already normal, but we need to normalize\n  // the relative position to only get its direction.\n  const relativeDirection = relativePosition.Normalized();\n\n  // Check if the alignment of the forward vector and relative direction\n  // is within some acceptable range of tolerance\n  return unit.GetForwardVector().Dot(relativeDirection) > 0.7;\n}\n"))),(0,o.kt)("h3",{id:"checking-if-unit-is-attacked-from-behind"},"Checking if unit is attacked from behind"),(0,o.kt)("p",null,"This question is similar to the previous question, only now there are two units facing in different ways:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/uLT3QzQ.png",alt:"Attacking from behind"})),(0,o.kt)("p",null,"Looking at this drawing it becomes obvious that the forward vector of unit 2 (F2) actually does ",(0,o.kt)("strong",{parentName:"p"},"not")," matter. What matters is the angle (dot product) between the forward vector of the unit getting attacked, and the where the attack is coming from (the vector from unit 2 to unit 1: ",(0,o.kt)("inlineCode",{parentName:"p"},"P1 - P2"),")"),(0,o.kt)(a.s,{group:"vscripts",mdxType:"MultiCodeBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"function isAttackedFromBehind(victim, attacker)\n  -- Calculate the relative position from attacker to victim (P1 - P2)\n  local relativePosition = victim:GetAbsOrigin() - attacker:GetAbsOrigin()\n  -- Normalize relative position to get attack direction\n  local attackDirection = relativePosition:Normalized()\n  -- Get the forward vector of the victim\n  local victimForward = victim:GetForwardVector()\n\n  -- Check if both normal(!) vectors are pointing in the same direction\n  return victimForward:Dot(attackDirection) > 0.7\nend\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"function isAttackedFromBehind(victim: CDOTA_BaseNPC, attacker: CDOTA_BaseNPC): boolean {\n  // Calculate the relative position from attacker to victim (P1 - P2)\n  const relativePosition = (victim.GetAbsOrigin() - attacker.GetAbsOrigin()) as Vector;\n  // Normalize relative position to get attack direction\n  const attackDirection = relativePosition.Normalized();\n  // Get the forward vector of the victim\n  const victimForward = victim.GetForwardVector();\n\n  // Check if both normal(!) vectors are pointing in the same direction\n  return victimForward.Dot(attackDirection) > 0.7;\n}\n"))),(0,o.kt)("h3",{id:"creating-some-effects-around-player"},"Creating some effects around player"),(0,o.kt)("p",null,"Consider the case where you want multiple things to happen evenly spaced in a circle around the player character. We can visualize it as follows:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/TOqC1Ly.png",alt:"Circular effect"})),(0,o.kt)("p",null,"By now it should be obvious we need to add the green vectors to the player position, the question is however how do you calculate these green vectors?"),(0,o.kt)("p",null,"What we can simply do is divide the full circle radius (2 ","*"," pi) by the number of points we want to use, and then for each angle calculate the unit vector from the angle, multiply it with the desired length and add it to the player position:"),(0,o.kt)(a.s,{group:"vscripts",mdxType:"MultiCodeBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"-- Calculate the angle between each point on the circle\n-- (This is in radians, the full circle is 2*pi radians)\nlocal angle = 2 * math.pi / numPoints\n\nfor i=1,numPoints do\n  -- Create direction vector from the angle\n  local direction = Vector(math.cos(angle * i), math.sin(angle * i))\n  -- Multiply the direction (length 1) with the desired radius of the circle\n  local circlePoint = direction * radius\n\n  -- Add the calculated green vector to the player position and do something\n  doSomething(player:GetAbsOrigin() + circlePoint)\nend\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// Calculate the angle between each point on the circle\n// (This is in radians, the full circle is 2*pi radians)\nconst angle = (2 * Math.PI) / numPoints;\n\nfor (let i = 0; i < numPoints; i++) {\n  // Create direction vector from the angle\n  const direction = Vector(Math.cos(angle * i), Math.sin(angle * i));\n  // Multiply the direction (length 1) with the desired radius of the circle\n  const circlePoint = (direction * radius) as Vector;\n\n  // Add the calculated green vector to the player position and do something\n  doSomething((player.GetAbsOrigin() + circlePoint) as Vector);\n}\n"))),(0,o.kt)("h3",{id:"physics-with-vectors---homing-projectile"},"Physics with vectors - Homing projectile"),(0,o.kt)("p",null,"As you have seen vector math is quite powerful and can be used to express positional and movement concepts in simple statements. In this final example I will show how to a simple 'physics' simulation to create a homing projectile."),(0,o.kt)("p",null,"We will express the projectile using two vectors: ",(0,o.kt)("inlineCode",{parentName:"p"},"position")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"velocity"),". This makes the projectile unable to instantly change its direction, but suffer some inertia: it will home in on the player on every tick, but it cannot easily slow down or change direction:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/GVK8Nbo.png",alt:null})),(0,o.kt)("p",null,"To achieve this effect we simply 'accelerate' the velocity of the projectile towards the player on every update, so the velocity turns towards the player a little bit every update. We then simply update the position based on the current velocity:"),(0,o.kt)(a.s,{group:"vscripts",mdxType:"MultiCodeBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"function updateProjectile(projectile, target)\n    -- Calculate direction from projectile to target\n    local relativeTargetPos = target:GetAbsOrigin() - projectile:GetAbsOrigin()\n    local targetDirection = relativeTargetPos:Normalized()\n\n    -- Now we update the projectile velocity to point more to the target\n    -- Note: you can increase/decrease acceleration to make it change direction\n    -- faster or slower\n    projectile.velocity = projectile.velocity + targetDirection * acceleration\n\n    -- Next we update the projectile position by simply adding the velocity\n    projectile.position = projectile.position + projectile.velocity\nend\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"function updateProjectile(projectile: Projectile, target: CDOTA_BaseNPC): void {\n  // Calculate direction from projectile to target\n  const relativeTargetPos = (target.GetAbsOrigin() - projectile.GetAbsOrigin()) as Vector;\n  const targetDirection = relativeTargetPos.Normalized();\n\n  // Now we update the projectile velocity to point more to the target\n  // Note: you can increase/decrease acceleration to make it change direction\n  // faster or slower\n  projectile.velocity = (projectile.velocity + targetDirection * acceleration) as Vector;\n\n  // Next we update the projectile position by simply adding the velocity\n  projectile.position = (projectile.position + projectile.velocity) as Vector;\n}\n"))))}p.isMDXComponent=!0},6010:(e,t,i)=>{function n(e){var t,i,o="";if("string"==typeof e||"number"==typeof e)o+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(i=n(e[t]))&&(o&&(o+=" "),o+=i);else for(t in e)e[t]&&(o&&(o+=" "),o+=t);return o}function o(){for(var e,t,i=0,o="";i<arguments.length;)(e=arguments[i++])&&(t=n(e))&&(o&&(o+=" "),o+=t);return o}i.d(t,{Z:()=>o})}}]);