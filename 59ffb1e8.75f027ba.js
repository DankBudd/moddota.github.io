(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{124:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(2),i=(n(0),n(191)),r=(n(183),n(184),n(192));n(193),n(194),n(195);const l={title:"Lua Item Tutorial",author:"DrTeaSpoon",steamId:"76561197975484185",date:"07.08.2015"},o={id:"abilities/lua-item-tutorial",isDocsHomePage:!1,title:"Lua Item Tutorial",description:"This tutorial is walk-through of creating completely new item with the new item_lua base class.",source:"@site/_articles/abilities/lua-item-tutorial.md",permalink:"/abilities/lua-item-tutorial",editUrl:"https://github.com/ModDota/moddota.github.io/edit/source/_articles/abilities/lua-item-tutorial.md",sidebar:"tutorials",previous:{title:"Calling Spells with SetCursor",permalink:"/abilities/calling-spells-with-setcursor"},next:{title:"Extending Hero/NPC API with lua modifiers",permalink:"/abilities/lua-modifiers/1"}},s=[{value:"Blink Staff",id:"blink-staff",children:[]},{value:"Defining Cast Rules",id:"defining-cast-rules",children:[]},{value:"Cast on Allied",id:"cast-on-allied",children:[]},{value:"Recipe and Stats",id:"recipe-and-stats",children:[]},{value:"Advanced Uses",id:"advanced-uses",children:[]},{value:"Item Levels",id:"item-levels",children:[]},{value:"The End",id:"the-end",children:[]}],c={rightToc:s};function u({components:e,...t}){return Object(i.b)("wrapper",Object(a.a)({},c,t,{components:e,mdxType:"MDXLayout"}),Object(i.b)("p",null,"This tutorial is walk-through of creating completely new item with the new item_lua base class. ",Object(i.b)("br",null),"\nFor this first tutorial we create upgrade from Blink Dagger to Blink Staff. How it will work is that when targeting any point in ground it will work like Blink Dagger does but if you target allied Unit you can 'tag' it to blink instead of you. We will also add passive bonuses from the item we will have in the recipe."),Object(i.b)("h3",{id:"blink-staff"},"Blink Staff"),Object(i.b)("p",null,"First open up your npc_items_custom.txt in your favourite text editor. (I use notepad++) If  you don't have this file in your scripts\\npc\\ folder then create it and copy following into it."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'"DOTAAbilities"\n{\n}\n')),Object(i.b)("p",null,'First and most important thing is naming your item. for this example I will use "item_blink_staff". Note that using the same name when referring to this item is important as dota 2 assumes some naming schemes.',Object(i.b)("br",null),"\nWe will also setup unique ID for the item and a base class that tells the game that we are intending to create a lua item."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'"DOTAAbilities"\n{\n    "item_blink_staff"\n    {\n        "ID"                            "1250" // anything above 1250 should be safe to use.\n        "BaseClass"                     "item_lua"\n    }\n}\n')),Object(i.b)("p",null,'Next we need an image for the item. For that we use "AbilityTextureName" as items classify as sort of abilities in dota 2. Its important that we have our image file in correct place and named correctly. ',Object(i.b)("br",null),"For item in this example the file should be found from following path:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{})," dota 2 beta\\game\\dota_addons\\{your addon name}\\resource\\flash3\\images\\items\\blink_staff.png\n")),Object(i.b)("p",null,"note that the file name is 'blink_staff.png' instead of 'item_blink_staff.png'. This is because dota will read ability texture name of 'item_blink_staff' as 'item\\blink_staff.png'",Object(i.b)("br",null),"It is also important to note that using same name for your ability texture is doubly important as the image in shop doesn't appear correctly if you use different name.",Object(i.b)("br",null),"\nThe image I will be using for this item is this one: ",Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"https://i.imgur.com/yz4ghPc.png",alt:"enter image description here",title:"blink_staff.png"})),Object(i.b)("br",null)),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'"DOTAAbilities"\n{\n    "item_blink_staff"\n    {\n        "ID"                            "1250" // anything above 1250 should be safe to use.\n        "BaseClass"                     "item_lua"\n        "AbilityTextureName"            "item_blink_staff"\n    }\n}\n')),Object(i.b)("p",null,"The last part we must add is link to the script file. You should create new *.lua file somewhere in your scripts\\vscripts folder. You can even create sub-folder for it if you want to be organized. Now your 'npc_items_custom.txt' should be something like this."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'"DOTAAbilities"\n{\n    "item_blink_staff"\n    {\n        "ID"                            "1250" // anything above 1250 should be safe to use.\n        "BaseClass"                     "item_lua"\n        "AbilityTextureName"            "item_blink_staff"\n        "ScriptFile"                    "lua_items/blink_staff/blink_staff.lua"\n    }\n}\n')),Object(i.b)("p",null,"Truth of the lua items and abilities is that all you really need to define for them in lua file is their class table. So lets create that into our lua file:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"if item_blink_staff == nil then\n    item_blink_staff = class({})\nend\n")),Object(i.b)("p",null,"IMPORTANT: Make sure you use same name as you defined in your npc_items_custom.txt",Object(i.b)("br",null),"\nNow next we want to define cooldown and mana cost for our blink staff. This can be done through 'npc_items_custom.txt' or through lua. Note that everything we define through lua we can manipulate more dynamically. For example we could reduce cooldown by half durring night time or double the mana cost if player has positive k/d ratio.",Object(i.b)("br",null),"\nAlso advantage of defining them in npc_items_custom.txt is that what ever shows in the store (before player has the item) is the values defined there. Also currently there is issue that Manacost will always display the value defined by 'npc_item_custom.txt' but the item will still grey(blue?)-out when your mana is lower than what is defined in lua for mana cost.",Object(i.b)("br",null),"\nBecause we want things to look smooth lets define some basic parameters we can later over ride in lua as we like:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'"DOTAAbilities"\n{\n    "item_blink_staff"\n    {\n        "ID"                            "1250" // anything above 1250 should be safe to use.\n        "BaseClass"                     "item_lua"\n        "AbilityTextureName"            "item_blink_staff"\n        "ScriptFile"                    "lua_items/blink_staff/blink_staff.lua"\n        // Casting\n        //--------------------------------------------\n        "AbilityCastRange"              "0" //We could define limit here but blink dagger has unlimited range to let player use it more efficiently. The range limiting comes in the script. 0 means unlimited.\n        "AbilityCastPoint"              "0.3" //It\'s the wind up time of spell.\n        "AbilityCooldown"               "10.0"\n        "AbilityManaCost"               "50"\n    }\n}\n')),Object(i.b)("p",null,"For more key-value stuff involving items use Noyas guide: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://moddota.com/forums/discussion/4/datadriven-items"}),"http://moddota.com/forums/discussion/4/datadriven-items")),Object(i.b)("br",null)," Its great reference but lets get on with the lua stuff!",Object(i.b)("h3",{id:"defining-cast-rules"},"Defining Cast Rules"),Object(i.b)("p",null,"First we add behaviours. This will define what happens when player activates the hot-key of the item."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function item_blink_staff:GetBehavior() \n    local behav = DOTA_ABILITY_BEHAVIOR_POINT + DOTA_ABILITY_BEHAVIOR_UNIT_TARGET + DOTA_ABILITY_BEHAVIOR_ROOT_DISABLES\n    return behav\nend\n")),Object(i.b)("p",null,"The GetBehaviour() function is called by the engine when it needs to know how the ability should act on different occations. The 'return' should return number 'int' value. Valve has made defining this easy for us by providing them as keys we can just sum together. These values take advantage of bit band where for example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"Key ------ Value ------ Bytes\nDOTA_ABILITY_BEHAVIOR_UNIT_TARGET ------ 8 ------ 01000\nDOTA_ABILITY_BEHAVIOR_POINT ------ 16 ------ 10000\nDOTA_ABILITY_BEHAVIOR_UNIT_TARGET + DOTA_ABILITY_BEHAVIOR_POINT ------ 24 ------ 11000\n")),Object(i.b)("p",null,"As you can see in the bytes, while the value might look arbitrary, the bytes act like on/off switch of the behaviour.\nFor available values for the behaviours use following link: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/API#DOTA_ABILITY_BEHAVIOR"}),"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/API#DOTA_ABILITY_BEHAVIOR")),Object(i.b)("p",null,"Next we add mana cost and cooldown."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function item_blink_staff:GetManaCost()\n    return 50\nend\n\nfunction item_blink_staff:GetCooldown( nLevel )\n    return 10\nend\n")),Object(i.b)("p",null,"As items are defined like abilities the GetCooldown function has helper parameter for level of the ability. You can ignore it for items completely as the level will almost always be 1 (exception  of corner cases like bkb or dagon.)"),Object(i.b)("p",null,"Now lets get to the actual spell casting part."),Object(i.b)("p",null,"First we create OnSpellStart() function and define some initial keys to use in the script."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function item_blink_staff:OnSpellStart()\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local hTarget = false --We might not have target so we make fail-safe so we do not get an error when calling - self:GetCursorTarget()\n    if not self:GetCursorTargetingNothing() then\n        hTarget = self:GetCursorTarget()\n    end\n    local vPoint = self:GetCursorPosition() --We will always have Vector for the point.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster's location\n    local nMaxBlink = 1200 --How far can we actually blink?\n    local nClamp = 960 --If we try to over reach we use this value instead. (this is mechanic from blink dagger.)\nend\n")),Object(i.b)("p",null,"Note that while we are in 'item_blink_staff' class we can use 'self' as quick reference to it.",Object(i.b)("br",null),"\nNow that we have our stuff set up lets start blinking our caster!"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'function item_blink_staff:OnSpellStart()\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local hTarget = false --We might not have target so we make fail-safe so we do not get an error when calling - self:GetCursorTarget()\n    if not self:GetCursorTargetingNothing() then\n        hTarget = self:GetCursorTarget()\n    end\n    local vPoint = self:GetCursorPosition() --We will always have Vector for the point.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local nMaxBlink = 1200 --How far can we actually blink?\n    local nClamp = 960 --If we try to over reach we use this value instead. (this is mechanic from blink dagger.)\n    \n    ProjectileManager:ProjectileDodge(hCaster)  --We disjoint disjointable incoming projectiles.\n    ParticleManager:CreateParticle("particles/items_fx/blink_dagger_start.vpcf", PATTACH_ABSORIGIN, hCaster) --Create particle effect at our caster.\n    hCaster:EmitSound("DOTA_Item.BlinkDagger.Activate") --Emit sound for the blink\n    local vDiff = vPoint - vOrigin --Difference between the points\n    if vDiff:Length2D() > nMaxBlink then  --Check caster is over reaching.\n        vPoint = vOrigin + (vPoint - vOrigin):Normalized() * nClamp -- Recalculation of the target point.\n    end\n    hCaster:SetAbsOrigin(vPoint) --We move the caster instantly to the location\n    FindClearSpaceForUnit(hCaster, vPoint, false) --This makes sure our caster does not get stuck\n    ParticleManager:CreateParticle("particles/items_fx/blink_dagger_end.vpcf", PATTACH_ABSORIGIN, hCaster) --Create particle effect at our caster.\nend\n')),Object(i.b)("p",null,"IMPORTANT: We are using sounds and particle effects already precached by default. If you wish to use particle effects and sounds from other heroes or your custom ones then you have to do precaching for those resources.",Object(i.b)("br",null),"\nThis is what our item should do right now:"),Object(i.b)(r.a,{id:"RepentantYellowishDiscus",mdxType:"Gfycat"}),Object(i.b)("h3",{id:"cast-on-allied"},"Cast on Allied"),Object(i.b)("p",null,"Now we are going to create the part that makes this item unique compared to blink dagger. First we if statement in our cast function that distinguishes how it should act depending on the target. Also at same time we make sure that double tapping the item works like it does with blink dagger (self targeting blinks towards base)"),Object(i.b)("p",null,"Because this lua ability stuff still has some minor issues we have to return to our 'npc_items_custom.txt' file to add some targeting help. Just add the following to the item."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'        "AbilityUnitTargetTeam"         "DOTA_UNIT_TARGET_TEAM_FRIENDLY"\n        "AbilityUnitTargetType"         "DOTA_UNIT_TARGET_HERO | DOTA_UNIT_TARGET_BASIC"\n')),Object(i.b)("p",null,"Now looking at our lua code you can see that we can use most of our writen blink code in multiple places. Thats why we are going to change things around a bit like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'function item_blink_staff:OnSpellStart()\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local hTarget = false --We might not have target so we make fail-safe so we do not get an error when calling - self:GetCursorTarget()\n    if not self:GetCursorTargetingNothing() then\n        hTarget = self:GetCursorTarget()\n    end\n    local vPoint = self:GetCursorPosition() --We will always have Vector for the point.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local nMaxBlink = 1200 --How far can we actually blink?\n    local nClamp = 960 --If we try to over reach we use this value instead. (this is mechanic from blink dagger.)\n    self:Blink(hCaster, vPoint, nMaxBlink, nClamp)\nend\n\n\nfunction item_blink_staff:Blink(hTarget, vPoint, nMaxBlink, nClamp)\n    local vOrigin = hTarget:GetAbsOrigin() --Our units\'s location\n    ProjectileManager:ProjectileDodge(hTarget)  --We disjoint disjointable incoming projectiles.\n    ParticleManager:CreateParticle("particles/items_fx/blink_dagger_start.vpcf", PATTACH_ABSORIGIN, hTarget) --Create particle effect at our caster.\n    hTarget:EmitSound("DOTA_Item.BlinkDagger.Activate") --Emit sound for the blink\n    local vDiff = vPoint - vOrigin --Difference between the points\n    if vDiff:Length2D() > nMaxBlink then  --Check caster is over reaching.\n        vPoint = vOrigin + (vPoint - vOrigin):Normalized() * nClamp -- Recalculation of the target point.\n    end\n    hTarget:SetAbsOrigin(vPoint) --We move the caster instantly to the location\n    FindClearSpaceForUnit(hTarget, vPoint, false) --This makes sure our caster does not get stuck\n    ParticleManager:CreateParticle("particles/items_fx/blink_dagger_end.vpcf", PATTACH_ABSORIGIN, hTarget) --Create particle effect at our caster.\nend\n')),Object(i.b)("p",null,"Now we can just use the newly defined Blink function to blink our caster, and allies without writing it all again.",Object(i.b)("br",null),"\nLets write the self cast now. We create IF statement first to check if we have hTarget. Then we check if the target is same as the caster or not. Also if we don't have hTarget we default to blinking ourselves. To get the location we want to blink towards we need to find some target location. For this we will use the fountain. (ent_dota_fountain)"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function item_blink_staff:OnSpellStart()\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local hTarget = false --We might not have target so we make fail-safe so we do not get an error when calling - self:GetCursorTarget()\n    if not self:GetCursorTargetingNothing() then\n        hTarget = self:GetCursorTarget()\n    end\n    local vPoint = self:GetCursorPosition() --We will always have Vector for the point.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster's location\n    local nMaxBlink = 1200 --How far can we actually blink?\n    local nClamp = 960 --If we try to over reach we use this value instead. (this is mechanic from blink dagger.)\n    if hTarget then\n        if hCaster == hTarget then\n            if not self.hFountain and not self.bNoFountain then --We check if we have ever tried finding the fountain before.\n            local hFountain = Entities:FindByClassname(nil, \"ent_dota_fountain\") --Find first fountain\n            local bFound = false --Make the boolean for while statement.\n                while not bFound do\n                    if hFountain then --Is there a fountain entity?\n                        if hFountain:GetTeamNumber() == hCaster:GetTeamNumber() then -- Is it the right team?\n                            self.hFountain = hFountain --Store it so we don't have to trouble finding the foundtain again.\n                            bFound = true --Make sure while statement ends\n                        else\n                            hFountain = Entities:FindByClassname(hFountain, \"ent_dota_fountain\") --Find the next fountain if we didn't find the right team.\n                        end\n                    else\n                        self.bNoFountain = true --We have concluded that there is no fountain entity for this team. Lets not do that again!\n                        bFound = true --We could alternatively use 'Break' but I find this more funny.\n                    end\n                end\n            end\n            if self.hFountain then --Do we have fountain?\n                vPoint = self.hFountain:GetAbsOrigin() --Lets change our target location there then.\n                self:Blink(hCaster, vPoint, nMaxBlink, nClamp) --BLINK!\n            else\n                self:EndCooldown() \n                self:RefundManaCost() \n            end\n        end\n    else\n        self:Blink(hCaster, vPoint, nMaxBlink, nClamp) --BLINK!\n    end\nend\n")),Object(i.b)("p",null,"As you can see, this time we used while statement to go through all fountain entities and stored the results of our search into the ability. If it finds no entities it saves a boolean value so that it won't try to find fountain the next time. Also just like blink dagger if the target cannot be found the we won't blink at all."),Object(i.b)("br",null),'Next we need to allow targeting allies with the spell but instead of blinking we store their id for next time we do "point" targeting on ground. There are few ways we can do this but It would be fair if we give them some sort of warning what is happening. So lets create two modifiers. One will simply be effect on target ally and one will be hidden modifier to store the target\'s entity index for short duration.',Object(i.b)("p",null,"First we need to link our intended modifiers to the ability. Top of your blink staff lua file should look like this"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'if item_blink_staff == nil then\n    item_blink_staff = class({})\nend\n\nLinkLuaModifier( "item_blink_staff_effect_modifier", "lua_items/blink_staff/effect_modifier.lua", LUA_MODIFIER_MOTION_NONE )\n')),Object(i.b)("p",null,"Then we need our effect modifier file that was declared. For purposes of this tutorial we will use particle effect for armlet so we can skip precache again."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'if item_blink_staff_effect_modifier == nil then\n    item_blink_staff_effect_modifier = class({})\nend\n\nfunction item_blink_staff_effect_modifier:OnCreated( kv )   \n    if IsServer() then\n        if self:GetCaster() ~= self:GetParent() then\n            local nFXIndex = ParticleManager:CreateParticle("particles/items_fx/armlet.vpcf", PATTACH_ROOTBONE_FOLLOW, self:GetParent())\n            self:AddParticle( nFXIndex, false, false, -1, false, false )\n        end\n    end\nend\n\nfunction item_blink_staff_effect_modifier:GetAttributes() \n    return MODIFIER_ATTRIBUTE_MULTIPLE + MODIFIER_ATTRIBUTE_IGNORE_INVULNERABLE\nend\n\nfunction item_blink_staff_effect_modifier:IsHidden()\n    if self:GetCaster() == self:GetParent() then\n    return true\n    else\n    return false\n    end\nend\n')),Object(i.b)("p",null,"As you can see we for the first time used IsServer() function. This is used so some of the game logic is not ran multiple times (as some portions of the code is ran on both clients and server)\nAlso for purposes of this tutorial we will use this same effect for both the caster and the target of the blink staff. We could create two modifiers but that would be wasteful. That's why we added some extra functionality to the modifier so we can distinguish if the target of the modifier is the caster or not. Also in case there are more than one blink staff in game we make sure there can be multiple modifiers of the same type on single unit."),Object(i.b)("p",null,"Now we need to add the code that lets us add the modifier to the target and store that target's entity index to our modifier and when point casting retrieve the target again. For this tutorial we give player five seconds to recast. We also end cooldown and refund mana cost on ally target."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'function item_blink_staff:OnSpellStart()\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local hTarget = false --We might not have target so we make fail-safe so we do not get an error when calling - self:GetCursorTarget()\n    if not self:GetCursorTargetingNothing() then\n        hTarget = self:GetCursorTarget()\n    end\n    local vPoint = self:GetCursorPosition() --We will always have Vector for the point.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local nMaxBlink = 1200 --How far can we actually blink?\n    local nClamp = 960 --If we try to over reach we use this value instead. (this is mechanic from blink dagger.)\n    if hTarget then\n        if hCaster == hTarget then\n            if not self.hFountain and not self.bNoFountain then --We check if we have ever tried finding the fountain before.\n            local hFountain = Entities:FindByClassname(nil, "ent_dota_fountain") --Find first fountain\n            local bFound = false --Make the boolean for while statement.\n                while not bFound do\n                    if hFountain then --Is there a fountain entity?\n                        if hFountain:GetTeamNumber() == hCaster:GetTeamNumber() then -- Is it the right team?\n                            self.hFountain = hFountain --Store it so we don\'t have to trouble finding the foundtain again.\n                            bFound = true --Make sure while statement ends\n                        else\n                            hFountain = Entities:FindByClassname(hFountain, "ent_dota_fountain") --Find the next fountain if we didn\'t find the right team.\n                        end\n                    else\n                        self.bNoFountain = true --We have concluded that there is no fountain entity for this team. Lets not do that again!\n                        bFound = true --We could alternatively use \'Break\' but I find this more funny.\n                    end\n                end\n            end\n            if self.hFountain then --Do we have fountain?\n                vPoint = self.hFountain:GetAbsOrigin() --Lets change our target location there then.\n                self:Blink(hCaster, vPoint, nMaxBlink, nClamp) --BLINK!\n            else\n                self:EndCooldown() --Cooldown refund if we could not find fountain on self cast\n                self:RefundManaCost() --Manacost refund if we could not find fountain on self cast\n            end\n        else\n            hTarget:AddNewModifier( hCaster, self, "item_blink_staff_effect_modifier", { duration = 5 } ) --lets add modifier to target\n            hCaster:AddNewModifier( hCaster, self, "item_blink_staff_effect_modifier", { duration = 5 } ) --lets add modifier to caster\n            local hModifier = hCaster:FindModifierByNameAndCaster("item_blink_staff_effect_modifier", hCaster) --find that modifier (they really should fix this by returning handle when adding new modifier.\n            local nTargetIndex = hTarget:GetEntityIndex() --lets find the targets entity index\n            hModifier:SetStackCount(nTargetIndex) --add that index to the modifier as it\'s stack count\n            self:EndCooldown() --Cooldown refund so can cast again\n            self:RefundManaCost() --Manacost refund\n        end\n    else\n    \n        local hModifier = hCaster:FindModifierByNameAndCaster("item_blink_staff_effect_modifier", hCaster) --Check if we have someone selected\n        if hModifier then\n            hTarget = EntIndexToHScript(hModifier:GetStackCount()) --Find the target with the ent index\n            if hTarget:FindModifierByNameAndCaster("item_blink_staff_effect_modifier", hCaster) then --Check if the target is not purged.\n                self:Blink(hTarget, vPoint, nMaxBlink, nClamp) --BLINK!\n            else --Someone purged our target\n            self:Blink(hCaster, vPoint, nMaxBlink, nClamp) --BLINK!\n            end\n        else\n            self:Blink(hCaster, vPoint, nMaxBlink, nClamp) --BLINK!\n        end\n    end\nend\n')),Object(i.b)("p",null,"Now there are two more things we need to do before we are done with our lua script. Right now this item has unlimited cast range for purposes of targeting allied unit. We also have issue of this item being abused when target does not want to be 'helped' by another. (Aka. Disable Help)",Object(i.b)("br",null)," Luckyly we have one tool for both of them: CastFilterResultTarget and GetCustomCastErrorTarget.",Object(i.b)("br",null),"Lets add following functions to our item's script:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"\nfunction item_blink_staff:CastFilterResultTarget( hTarget ) -- hTarget is the targeted NPC.\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster's location\n    local vPoint = hTarget:GetAbsOrigin() --Our target's location\n    local nMaxRange = 1200 --How far can we actually target?\n    local vDiff = vPoint - vOrigin --Difference between the points\n    local nTargetID = hTarget:GetPlayerOwnerID() --getting targets owner id\n    local nCasterID = hCaster:GetPlayerOwnerID() --getting casters owner id\n    if nTargetID and nCasterID then --making sure they both exist\n        if PlayerResource:IsDisableHelpSetForPlayerID(nTargetID, nCasterID) then --target hates having caster help him out.\n            return UF_FAIL_CUSTOM\n        end\n    end\n    \n    if vDiff:Length2D() > nMaxRange then  --Check caster is over reaching.\n    return UF_FAIL_CUSTOM\n    else\n    return UF_SUCCESS\n    end\nend\n\nfunction item_blink_staff:GetCustomCastErrorTarget( hTarget) -- hTarget is the targeted NPC. \n    local hCaster = self:GetCaster() --We will always have Caster.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster's location\n    local vPoint = hTarget:GetAbsOrigin() --Our target's location\n    local nMaxRange = 1200 --How far can we actually target?\n    local vDiff = vPoint - vOrigin --Difference between the points\n    local nTargetID = hTarget:GetPlayerOwnerID() --getting targets owner id\n    local nCasterID = hCaster:GetPlayerOwnerID() --getting casters owner id\n    if nTargetID and nCasterID then --making sure they both exist\n        if PlayerResource:IsDisableHelpSetForPlayerID(nTargetID, nCasterID) then --target hates having caster help him out.\n            return \"#dota_hud_error_target_has_disable_help\"\n        end\n    end\n    if vDiff:Length2D() > nMaxRange then  --Check caster is over reaching.\n    return \"#dota_hud_error_target_out_of_range\" --returning error from localization\n    end\nend\n")),Object(i.b)("p",null,"Now to save time and sanity you might want to add 'Special' values to your script. These are values you can modify easily without opening the script and searching for them there. This is extremely helpful when you use those values in multiple places. It also lets you display the values in your item description.",Object(i.b)("br",null),"First add following block to your item in 'npc_items_custom.txt'"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'\n        "AbilitySpecial"\n        {\n            "01"\n            {\n                "var_type"              "FIELD_INTEGER"\n                "max_blink"             "1200"\n            }\n            "02"\n            {\n                "var_type"              "FIELD_INTEGER"\n                "blink_clamp"           "960"\n            }\n            "03"\n            {\n                "var_type"              "FIELD_INTEGER"\n                "help_range"            "3000"\n            }\n            "04"\n            {\n                "var_type"              "FIELD_FLOAT"\n                "help_duration"         "5.0"\n            }\n        }\n')),Object(i.b)("p",null,"Now to use these values you use this function in your ability:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'self:GetSpecialValueFor( "max_blink" )\n')),Object(i.b)("p",null,"Or in your modifier you have to get the handle for your ability first:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'self:GetAbility():GetSpecialValueFor( "max_blink" )\n')),Object(i.b)("p",null,"Now we find and replace all those values with correct retrieval of a special value and we should end up with following result:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'\nfunction item_blink_staff:OnSpellStart()\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local hTarget = false --We might not have target so we make fail-safe so we do not get an error when calling - self:GetCursorTarget()\n    if not self:GetCursorTargetingNothing() then\n        hTarget = self:GetCursorTarget()\n    end\n    local vPoint = self:GetCursorPosition() --We will always have Vector for the point.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local nMaxBlink = self:GetSpecialValueFor( "max_blink" ) --How far can we actually blink?\n    local nClamp = self:GetSpecialValueFor( "blink_clamp" ) --If we try to over reach we use this value instead. (this is mechanic from blink dagger.)\n    if hTarget then\n        if hCaster == hTarget then\n            if not self.hFountain and not self.bNoFountain then --We check if we have ever tried finding the fountain before.\n            local hFountain = Entities:FindByClassname(nil, "ent_dota_fountain") --Find first fountain\n            local bFound = false --Make the boolean for while statement.\n                while not bFound do\n                    if hFountain then --Is there a fountain entity?\n                        if hFountain:GetTeamNumber() == hCaster:GetTeamNumber() then -- Is it the right team?\n                            self.hFountain = hFountain --Store it so we don\'t have to trouble finding the foundtain again.\n                            bFound = true --Make sure while statement ends\n                        else\n                            hFountain = Entities:FindByClassname(hFountain, "ent_dota_fountain") --Find the next fountain if we didn\'t find the right team.\n                        end\n                    else\n                        self.bNoFountain = true --We have concluded that there is no fountain entity for this team. Lets not do that again!\n                        bFound = true --We could alternatively use \'Break\' but I find this more funny.\n                    end\n                end\n            end\n            if self.hFountain then --Do we have fountain?\n                vPoint = self.hFountain:GetAbsOrigin() --Lets change our target location there then.\n                self:Blink(hCaster, vPoint, nMaxBlink, nClamp) --BLINK!\n            else\n                self:EndCooldown() --Cooldown refund if we could not find fountain on self cast\n                self:RefundManaCost() --Manacost refund if we could not find fountain on self cast\n            end\n        else\n            hTarget:AddNewModifier( hCaster, self, "item_blink_staff_effect_modifier", { duration = self:GetSpecialValueFor( "help_duration" ) } ) --lets add modifier to target\n            hCaster:AddNewModifier( hCaster, self, "item_blink_staff_effect_modifier", { duration = self:GetSpecialValueFor( "help_duration" ) } ) --lets add modifier to caster\n            local hModifier = hCaster:FindModifierByNameAndCaster("item_blink_staff_effect_modifier", hCaster) --find that modifier (they really should fix this by returning handle when adding new modifier.\n            local nTargetIndex = hTarget:GetEntityIndex() --lets find the targets entity index\n            hModifier:SetStackCount(nTargetIndex) --add that index to the modifier as it\'s stack count\n            self:EndCooldown() --Cooldown refund so can cast again\n            self:RefundManaCost() --Manacost refund\n        end\n    else\n    \n        local hModifier = hCaster:FindModifierByNameAndCaster("item_blink_staff_effect_modifier", hCaster) --Check if we have someone selected\n        if hModifier then\n            hTarget = EntIndexToHScript(hModifier:GetStackCount()) --Find the target with the ent index\n            if hTarget:FindModifierByNameAndCaster("item_blink_staff_effect_modifier", hCaster) then --Check if the target is not purged.\n                self:Blink(hTarget, vPoint, nMaxBlink, nClamp) --BLINK!\n                \n            else --Someone purged our target\n            self:Blink(hCaster, vPoint, nMaxBlink, nClamp) --BLINK!\n            end\n        else\n            self:Blink(hCaster, vPoint, nMaxBlink, nClamp) --BLINK!\n        end\n    end\nend\n\n\nfunction item_blink_staff:Blink(hTarget, vPoint, nMaxBlink, nClamp)\n    local vOrigin = hTarget:GetAbsOrigin() --Our units\'s location\n    ProjectileManager:ProjectileDodge(hTarget)  --We disjoint disjointable incoming projectiles.\n    ParticleManager:CreateParticle("particles/items_fx/blink_dagger_start.vpcf", PATTACH_ABSORIGIN, hTarget) --Create particle effect at our caster.\n    hTarget:EmitSound("DOTA_Item.BlinkDagger.Activate") --Emit sound for the blink\n    local vDiff = vPoint - vOrigin --Difference between the points\n    if vDiff:Length2D() > nMaxBlink then  --Check caster is over reaching.\n        vPoint = vOrigin + (vPoint - vOrigin):Normalized() * nClamp -- Recalculation of the target point.\n    end\n    hTarget:SetAbsOrigin(vPoint) --We move the caster instantly to the location\n    FindClearSpaceForUnit(hTarget, vPoint, false) --This makes sure our caster does not get stuck\n    ParticleManager:CreateParticle("particles/items_fx/blink_dagger_end.vpcf", PATTACH_ABSORIGIN, hTarget) --Create particle effect at our caster.\nend\n\nfunction item_blink_staff:CastFilterResultTarget( hTarget ) -- hTarget is the targeted NPC.\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local vPoint = hTarget:GetAbsOrigin() --Our target\'s location\n    local nMaxRange = self:GetSpecialValueFor( "help_range" ) --How far can we actually target?\n    local vDiff = vPoint - vOrigin --Difference between the points\n    local nTargetID = hTarget:GetPlayerOwnerID() --getting targets owner id\n    local nCasterID = hCaster:GetPlayerOwnerID() --getting casters owner id\n    if nTargetID and nCasterID then --making sure they both exist\n        if PlayerResource:IsDisableHelpSetForPlayerID(nTargetID, nCasterID) then --target hates having caster help him out.\n            return UF_FAIL_CUSTOM\n        end\n    end\n    \n    if vDiff:Length2D() > nMaxRange then  --Check caster is over reaching.\n    return UF_FAIL_CUSTOM\n    else\n    return UF_SUCCESS\n    end\nend\n\nfunction item_blink_staff:GetCustomCastErrorTarget( hTarget) -- hTarget is the targeted NPC. \n    local hCaster = self:GetCaster() --We will always have Caster.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local vPoint = hTarget:GetAbsOrigin() --Our target\'s location\n    local nMaxRange = self:GetSpecialValueFor( "help_range" ) --How far can we actually target?\n    local vDiff = vPoint - vOrigin --Difference between the points\n    local nTargetID = hTarget:GetPlayerOwnerID() --getting targets owner id\n    local nCasterID = hCaster:GetPlayerOwnerID() --getting casters owner id\n    if nTargetID and nCasterID then --making sure they both exist\n        if PlayerResource:IsDisableHelpSetForPlayerID(nTargetID, nCasterID) then --target hates having caster help him out.\n            return "#dota_hud_error_target_has_disable_help"\n        end\n    end\n    if vDiff:Length2D() > nMaxRange then  --Check caster is over reaching.\n    return "#dota_hud_error_target_out_of_range" --returning error from localization\n    end\nend\n')),Object(i.b)("p",null,"Now if we want to make sure the consistancy between npc_items_custom.txt and our lua file is complete we can use self.BaseClass for things like cooldown or castrange. Lets replace our mana cost and cooldown functions to see how it works."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function item_blink_staff:GetManaCost()\n    return self.BaseClass.GetManaCost( self, nLevel )\nend\n\nfunction item_blink_staff:GetCooldown( nLevel )\n    return self.BaseClass.GetCooldown( self, nLevel )\nend\n")),Object(i.b)("p",null,"Now all we need to do is make localization for the item. In your 'dota 2 beta\\game\\dota_addons","{","addon name}\\resource' folder you should have addon_english.txt",Object(i.b)("br",null),"If you are using some different language you might use differently named file. But all languages defaults to english if others fail.",Object(i.b)("br",null),"\nOpen it up and lets add following lines to the mix."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'\n        "DOTA_Tooltip_ability_item_blink_staff"                                           "Blink Staff"\n        "DOTA_Tooltip_ability_item_blink_staff_Description"                               "Teleport to a target point up to 1200 units away. Can be used on allied units to select them to blink instead of you."\n        "DOTA_Tooltip_ability_item_blink_staff_max_blink"                                 "Max Blink Distance:"\n        "DOTA_Tooltip_ability_item_blink_staff_help_range"                                "Help Range:"\n        \n        "DOTA_Tooltip_item_blink_staff_effect_modifier"                                             "Blink Staff"\n        "DOTA_Tooltip_item_blink_staff_effect_modifier_Description"                                 "Targeted by Blink Staff"\n')),Object(i.b)("p",null,"Lets see what we have now:"),Object(i.b)(r.a,{id:"FrankBleakChihuahua",mdxType:"Gfycat"}),Object(i.b)("p",null,"Now there are still some things we need to do but first lets fix the most obvious problem. Currently there is a bug where the:",Object(i.b)("br",null),'\n"AbilityUnitTargetTeam"\t\t\t"DOTA_UNIT_TARGET_TEAM_FRIENDLY"',Object(i.b)("br",null),"\nIs ignored!",Object(i.b)("br",null),"\nWe can fix it by adding team check to our cast filters:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'\nfunction item_blink_staff:CastFilterResultTarget( hTarget ) -- hTarget is the targeted NPC.\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local vPoint = hTarget:GetAbsOrigin() --Our target\'s location\n    local nMaxRange = self:GetSpecialValueFor( "help_range" ) --How far can we actually target?\n    local vDiff = vPoint - vOrigin --Difference between the points\n    local nTargetID = hTarget:GetPlayerOwnerID() --getting targets owner id\n    local nCasterID = hCaster:GetPlayerOwnerID() --getting casters owner id\n    if hCaster:GetTeamNumber() ~= hTarget:GetTeamNumber() then\n        return UF_FAIL_CUSTOM\n    end\n    if nTargetID and nCasterID then --making sure they both exist\n        if PlayerResource:IsDisableHelpSetForPlayerID(nTargetID, nCasterID) then --target hates having caster help him out.\n            return UF_FAIL_CUSTOM\n        end\n    end\n    \n    if vDiff:Length2D() > nMaxRange then  --Check caster is over reaching.\n    return UF_FAIL_CUSTOM\n    else\n    return UF_SUCCESS\n    end\nend\n\nfunction item_blink_staff:GetCustomCastErrorTarget( hTarget) -- hTarget is the targeted NPC. \n    local hCaster = self:GetCaster() --We will always have Caster.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local vPoint = hTarget:GetAbsOrigin() --Our target\'s location\n    local nMaxRange = self:GetSpecialValueFor( "help_range" ) --How far can we actually target?\n    local vDiff = vPoint - vOrigin --Difference between the points\n    local nTargetID = hTarget:GetPlayerOwnerID() --getting targets owner id\n    local nCasterID = hCaster:GetPlayerOwnerID() --getting casters owner id\n    if hCaster:GetTeamNumber() ~= hTarget:GetTeamNumber() then\n        return "#dota_hud_error_cant_cast_on_enemy"\n    end\n    if nTargetID and nCasterID then --making sure they both exist\n        if PlayerResource:IsDisableHelpSetForPlayerID(nTargetID, nCasterID) then --target hates having caster help him out.\n            return "#dota_hud_error_target_has_disable_help"\n        end\n    end\n    if vDiff:Length2D() > nMaxRange then  --Check caster is over reaching.\n    return "#dota_hud_error_target_out_of_range" --returning error from localization\n    end\nend\n')),Object(i.b)("p",null,"Problem with this method is that its easier for user to blink towards the enemy rather than even try 'helping' him/her. But in this tutorial we assume you can figure it out your how to edit the code to blink when caster and target have different teams using the cast filter changes as example.",Object(i.b)("br",null),"\nNow the thing that makes blink dagger less as efficient as escape tool is it's Cooldown when hurt. Lets add that in! To do that we create Intrinsic modifier. Lets link our new modifier:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'LinkLuaModifier( "item_blink_staff_passive_modifier", "lua_items/blink_staff/passive_modifier.lua", LUA_MODIFIER_MOTION_NONE )\nfunction item_blink_staff:GetIntrinsicModifierName()\n    return "item_blink_staff_passive_modifier"\nend\n')),Object(i.b)("p",null,"Now create our declared lua file for it and its contents should be something like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'if item_blink_staff_passive_modifier == nil then\n    item_blink_staff_passive_modifier = class({})\nend\n\nfunction item_blink_staff_passive_modifier:IsHidden()\n    return true --we want item\'s passive abilities to be hidden most of the times\nend\n\nfunction item_blink_staff_passive_modifier:DeclareFunctions() --we want to use these functions in this item\n    local funcs = {\n        MODIFIER_EVENT_ON_TAKEDAMAGE\n    }\n \n    return funcs\nend\n\nfunction item_blink_staff_passive_modifier:OnTakeDamage( params ) --When ever the unit takes damage this is called\n    if IsServer() then --this should be only run on server.\n        local hAbility = self:GetAbility() --we get the ability where this modifier is from\n        if params.attacker ~= self:GetParent() and params.unit == self:GetParent() and  params.attacker:IsHero()  then\n        hAbility:StartCooldown(hAbility:GetSpecialValueFor( "hurt_cooldown" )) --we start the cooldown\n        end\n    end\nend\n')),Object(i.b)("p",null,"As you can see used declare functions to tell the game what to expect from this modifier. This makes sure the game doesn't check this modifier with every event that might be effected.",Object(i.b)("br",null),"\nWe also added new special value for cooldown when caster gets hurt. Remember to add that to your 'npc_items_custom.txt' as float value preferably."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'            "05"\n            {\n                "var_type"              "FIELD_FLOAT"\n                "hurt_cooldown"         "3.0"\n            }\n')),Object(i.b)("p",null,"Now we should have covered all the main issues. Next we add recipe for the item and add stats from the components."),Object(i.b)("h3",{id:"recipe-and-stats"},"Recipe and Stats"),Object(i.b)("p",null,"As you might have noticed testing our item, it right now costs no gold to purchase. There are two things we can do here. We can either add ItemCost into our 'npc_items_custom.txt' file or create a recipe for the item. When you create a recipe for your item the game automatically calculates the item cost. We can also add ItemCost to our new recipe to let the game know that you have to buy it aswell instead of items being automatically combined into one. We are also adding the stats from our component items so be sure to add special values to your item reflecting the component stats."),Object(i.b)("p",null,"I will be using item_quarterstaff, item_robe and item_blink for my components. I also make the recipe cost 325 gold. One important thing to note when creating recipe is the naming scheme. The recipe name should always be\n'item_recipe_your_item'",Object(i.b)("br",null),"\nmy item: item_blink_staff",Object(i.b)("br",null),"\nmy recipe: item_recipe_blink_staff",Object(i.b)("br",null),"\nAlso you must give each item in npc_items_custom.txt unique ID. If you don't you may find odd bugs like item not being purchasable. Here is my current entries in npc_items_custom.txt"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'\n    "item_blink_staff"\n    {\n        "ID"                            "1250"\n        "BaseClass"                     "item_lua"\n        "ScriptFile"                    "lua_items/blink_staff/blink_staff.lua"\n        "AbilityTextureName"            "item_blink_staff"\n        "AbilityUnitTargetTeam"         "DOTA_UNIT_TARGET_TEAM_FRIENDLY"\n        "AbilityUnitTargetType"         "DOTA_UNIT_TARGET_HERO | DOTA_UNIT_TARGET_BASIC"\n        "AbilityCastRange"              "0"\n        "AbilityCastPoint"              "0.3"\n        "AbilityCooldown"               "10.0"\n        "AbilityManaCost"               "50"\n        //// Item Info\n        ////-------------------------------------------------------------------------------------------------------------\n        "ItemCost"                      "3900"\n        "ItemShopTags"                  "blink;staff"\n        "ItemQuality"                   "rare"\n        "ItemAliases"                   "blink;staff"\n        //\n        "AbilitySpecial"\n        {\n            "01"\n            {\n                "var_type"              "FIELD_INTEGER"\n                "max_blink"             "1200"\n            }\n            "02"\n            {\n                "var_type"              "FIELD_INTEGER"\n                "blink_clamp"           "960"\n            }\n            "03"\n            {\n                "var_type"              "FIELD_INTEGER"\n                "help_range"            "3000"\n            }\n            "04"\n            {\n                "var_type"              "FIELD_FLOAT"\n                "help_duration"         "5.0"\n            }\n            "05"\n            {\n                "var_type"              "FIELD_FLOAT"\n                "hurt_cooldown"         "3.0"\n            }\n            \n            // Stats from the recipe items\n            \n            "06" // Quarterstaff\n            {\n                "var_type"              "FIELD_INTEGER"\n                "bonus_damage"          "10"\n            }\n            \n            "07" // Quarterstaff\n            {\n                "var_type"              "FIELD_INTEGER"\n                "bonus_attack_speed"            "10"\n            }\n            \n            "08" // Robe Of Magi\n            {\n                "var_type"              "FIELD_INTEGER"\n                "bonus_int"         "6"\n            }\n        }\n    }\n    \n    "item_recipe_blink_staff"\n    {\n        // General\n        //-------------------------------------------------------------------------------------------------------------\n        "BaseClass"                     "item_datadriven"\n        "ID"                            "1251"\n        \n        // Item Info\n        //-------------------------------------------------------------------------------------------------------------\n        "ItemCost"                      "325"   \n        "ItemShopTags"                  ""\n        \n        // Recipe\n        //-------------------------------------------------------------------------------------------------------------\n        "ItemRecipe"                    "1"\n        "ItemResult"                    "item_blink_staff"\n        "ItemRequirements"\n        {\n            "01"                        "item_quarterstaff;item_robe;item_blink"\n        }\n    }\n')),Object(i.b)("p",null,"Notice that the item requirements part lists the items you need. For valve defined ones use this as reference: ",Object(i.b)("br",null)," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/Built-In_Item_Names"}),"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/Built-In_Item_Names")," ",Object(i.b)("br",null),'\nAlso notice how the first entry is defined "01" . This is because you can create recipe that can be used with different sets of components. This is used by valve in Power Threads where you can use any of the basic 450 costing attribute items.',Object(i.b)("br",null),"\nNow while we have defined special values for our blink staff stats, we have not actually used those values anywhere. Lets get back to our blink staff passive modifier lua file we used for the cooldown when taking damage.",Object(i.b)("br",null),"\nHere we have to declare new functions for the stats we need."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function item_blink_staff_passive_modifier:DeclareFunctions() --we want to use these functions in this item\n    local funcs = {\n        MODIFIER_EVENT_ON_TAKEDAMAGE,\n        MODIFIER_PROPERTY_PREATTACK_BONUS_DAMAGE,\n        MODIFIER_PROPERTY_ATTACKSPEED_BONUS_CONSTANT,\n        MODIFIER_PROPERTY_STATS_INTELLECT_BONUS\n    }\n \n    return funcs\nend\n")),Object(i.b)("p",null,"Now that we have declared what we want to effect in game with this modifier lets add functions the game can call on the correct events."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'function item_blink_staff_passive_modifier:GetModifierBonusStats_Intellect()\n    local hAbility = self:GetAbility() --we get the ability where this modifier is from\n    return hAbility:GetSpecialValueFor( "bonus_int" )\nend\n\nfunction item_blink_staff_passive_modifier:GetModifierAttackSpeedBonus_Constant()\n    local hAbility = self:GetAbility() --we get the ability where this modifier is from\n    return hAbility:GetSpecialValueFor( "bonus_attack_speed" )\nend\n\nfunction item_blink_staff_passive_modifier:GetModifierPreAttack_BonusDamage()\n    local hAbility = self:GetAbility() --we get the ability where this modifier is from\n    return hAbility:GetSpecialValueFor( "bonus_damage" )\nend\n')),Object(i.b)("p",null,"Now last thing we need to do is tell player about the awe-inspiring stats this item gives them. Lets add our new stats to the addon_english.txt",Object(i.b)("br",null),"\nAfter that our file should have something like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'\n        "DOTA_Tooltip_ability_item_blink_staff"                                           "Blink Staff"\n        "DOTA_Tooltip_ability_item_blink_staff_Description"                               "Teleport to a target point up to 1200 units away. Can be used on allied units to select them to blink instead of you."\n        "DOTA_Tooltip_ability_item_blink_staff_max_blink"                                 "Max Blink Distance:"\n        "DOTA_Tooltip_ability_item_blink_staff_help_range"                                "Help Range:"\n        "DOTA_Tooltip_ability_item_blink_staff_bonus_damage"                              "+$damage"\n        "DOTA_Tooltip_ability_item_blink_staff_bonus_attack_speed"                        "+$attack"\n        "DOTA_Tooltip_ability_item_blink_staff_bonus_int"                                 "+$int"\n        \n        "DOTA_Tooltip_item_blink_staff_effect_modifier"                                             "Blink Staff"\n        "DOTA_Tooltip_item_blink_staff_effect_modifier_Description"                                 "Targeted by Blink Staff"\n')),Object(i.b)("p",null,"Now we are pretty much done. But because the biggest advantage of lua items is that we can define so many things dynamically so rest of this tutorial we will do few experiments that might not seem very balanced or sensible from game play perspective but just because we can!"),Object(i.b)("h3",{id:"advanced-uses"},"Advanced Uses"),Object(i.b)("p",null,"First Lets try effecting the help casting range if we are dealing with large mana pool hero. Since we are using cast filters for the help range limitation we can do this part there. To do this we use our already defined hCaster handle and use function :GetMaxMana() to return the hero's mana pool. Then we add that value to our already existing help range. This means that if our caster has 5000 mana pool to use late game he or she will have massive support range of 8000 units.",Object(i.b)("br",null),"\nSo lets change the CastFilterResult target and error functions with following:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'    local nRangeBonus = hCaster:GetMaxMana() --Get our caster\'s mana pool\n    local nMaxRange = self:GetSpecialValueFor( "help_range" ) + nRangeBonus--How far can we actually target?\n')),Object(i.b)("p",null,"The end result should look something like this"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'function item_blink_staff:CastFilterResultTarget( hTarget ) -- hTarget is the targeted NPC.\n    local hCaster = self:GetCaster() --We will always have Caster.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local vPoint = hTarget:GetAbsOrigin() --Our target\'s location\n    local nRangeBonus = hCaster:GetMaxMana() --Get our caster\'s mana pool\n    local nMaxRange = self:GetSpecialValueFor( "help_range" ) + nRangeBonus--How far can we actually target?\n    local vDiff = vPoint - vOrigin --Difference between the points\n    local nTargetID = hTarget:GetPlayerOwnerID() --getting targets owner id\n    local nCasterID = hCaster:GetPlayerOwnerID() --getting casters owner id\n    if hCaster:GetTeamNumber() ~= hTarget:GetTeamNumber() then\n        return UF_FAIL_CUSTOM\n    end\n    if nTargetID and nCasterID then --making sure they both exist\n        if PlayerResource:IsDisableHelpSetForPlayerID(nTargetID, nCasterID) then --target hates having caster help him out.\n            return UF_FAIL_CUSTOM\n        end\n    end\n    \n    if vDiff:Length2D() > nMaxRange then  --Check caster is over reaching.\n    return UF_FAIL_CUSTOM\n    else\n    return UF_SUCCESS\n    end\nend\n\nfunction item_blink_staff:GetCustomCastErrorTarget( hTarget) -- hTarget is the targeted NPC. \n    local hCaster = self:GetCaster() --We will always have Caster.\n    local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n    local vPoint = hTarget:GetAbsOrigin() --Our target\'s location\n    local nRangeBonus = hCaster:GetMaxMana() --Get our caster\'s mana pool\n    local nMaxRange = self:GetSpecialValueFor( "help_range" ) + nRangeBonus--How far can we actually target?\n    local vDiff = vPoint - vOrigin --Difference between the points\n    local nTargetID = hTarget:GetPlayerOwnerID() --getting targets owner id\n    local nCasterID = hCaster:GetPlayerOwnerID() --getting casters owner id\n    if hCaster:GetTeamNumber() ~= hTarget:GetTeamNumber() then\n        return "#dota_hud_error_cant_cast_on_enemy"\n    end\n    if nTargetID and nCasterID then --making sure they both exist\n        if PlayerResource:IsDisableHelpSetForPlayerID(nTargetID, nCasterID) then --target hates having caster help him out.\n            return "#dota_hud_error_target_has_disable_help"\n        end\n    end\n    if vDiff:Length2D() > nMaxRange then  --Check caster is over reaching.\n    return "#dota_hud_error_target_out_of_range" --returning error from localization\n    end\nend\n')),Object(i.b)("p",null,"Now you may have noticed how we are using almost same code for both cast filter and the error function. Here is a way to reduce the redundancy:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'function item_blink_staff:CastFilterResultTarget( hTarget ) -- hTarget is the targeted NPC.\n    return self:CCastFilter( hTarget, false )\nend\n\nfunction item_blink_staff:GetCustomCastErrorTarget( hTarget) -- hTarget is the targeted NPC. \n    return self:CCastFilter( hTarget, true )\nend\n\nfunction item_blink_staff:CCastFilter( hTarget, bError )\n    if IsServer() then --this should be only run on server.\n        local hCaster = self:GetCaster() --We will always have Caster.\n        local vOrigin = hCaster:GetAbsOrigin() --Our caster\'s location\n        local vPoint = hTarget:GetAbsOrigin() --Our target\'s location\n        local nRangeBonus = hCaster:GetMaxMana() --Get our caster\'s mana pool\n        local nMaxRange = self:GetSpecialValueFor( "help_range" ) + nRangeBonus--How far can we actually target?\n        local vDiff = vPoint - vOrigin --Difference between the points\n        local nTargetID = hTarget:GetPlayerOwnerID() --getting targets owner id\n        local nCasterID = hCaster:GetPlayerOwnerID() --getting casters owner id\n        if hCaster:GetTeamNumber() ~= hTarget:GetTeamNumber() then\n            if bError then\n                return "#dota_hud_error_cant_cast_on_enemy"\n            else\n                return UF_FAIL_CUSTOM\n            end\n        end\n        if nTargetID and nCasterID then --making sure they both exist\n            if PlayerResource:IsDisableHelpSetForPlayerID(nTargetID, nCasterID) then --target hates having caster help him out.\n                if bError then\n                    return "#dota_hud_error_target_has_disable_help"\n                else\n                    return UF_FAIL_CUSTOM\n                end\n            end\n        end\n        if vDiff:Length2D() > nMaxRange then  --Check caster is over reaching.\n            if bError then\n                return "#dota_hud_error_target_out_of_range" --returning error from localization\n            else\n                return UF_FAIL_CUSTOM\n            end\n        end\n        if not bError then\n            return UF_SUCCESS\n        end\n    end\nend\n')),Object(i.b)("h3",{id:"item-levels"},"Item Levels"),Object(i.b)("p",null,"As I mentioned early in the tutorial things like bkb and dagon has item levels used. Dagon uses separate items to define the levels while bkb has built-in leveling when ever it is used. We are going to code where we reduce our blink staff help range when ever it is used to help a player.",Object(i.b)("br",null),"First we need  to add new values for our help ranges between the levels. These are simply separated by spaces between values."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'            "03"\n            {\n                "var_type"              "FIELD_INTEGER"\n                "help_range"            "3000 2500 2000 1500 1000"\n            }\n')),Object(i.b)("p",null,"Because there is some odd bugs here and there, the MaxLevel value that we would use for normal abilities doesn't work for items. To help us define it in the script we create new special value for it."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'            "09"\n            {\n                "var_type"              "FIELD_INTEGER"\n                "max_level"             "5"\n            }\n')),Object(i.b)("p",null,"Back to the lua script, we need to upgrade the item only when ally is teleported and not when we simply tag our ally for teleport. First find this line:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"self:Blink(hTarget, vPoint, nMaxBlink, nClamp) --BLINK!\n")),Object(i.b)("p",null,"Under it lets add the upgrade part. Note that we have to check we don't upgrade the item when it's fully upgraded."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'if self:GetLevel() < self:GetSpecialValueFor( "max_level" ) then --We can\'t define max level for item like we can with abilities. Best to create special value for it.\n    self:UpgradeAbility(true)\nend\n')),Object(i.b)("p",null,"We could also add condition where if the game is currently in night time the upgrade doesn't happen. Letting our hero help his allies for free!"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'if self:GetLevel() < self:GetSpecialValueFor( "max_level" ) and GameRules:IsDaytime() then\n    self:UpgradeAbility(true)\nend\n')),Object(i.b)("p",null,"Now if we want to let our hero refresh the help range levels then we can either script some event where we reset the item's level with:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"self:SetLevel(1)\n")),Object(i.b)("p",null,"Or we can use more elegant choice of modifying our recipe to act like charge refresh for drums of endurance."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'\n    "item_recipe_blink_staff"\n    {\n        // General\n        //-------------------------------------------------------------------------------------------------------------\n        "BaseClass"                     "item_datadriven"\n        "ID"                            "1251"\n        \n        // Item Info\n        //-------------------------------------------------------------------------------------------------------------\n        "ItemCost"                      "325"   \n        "ItemShopTags"                  ""\n        \n        // Recipe\n        //-------------------------------------------------------------------------------------------------------------\n        "ItemRecipe"                    "1"\n        "ItemResult"                    "item_blink_staff"\n        "ItemRequirements"\n        {\n            "01"                        "item_quarterstaff;item_robe;item_blink"\n            "02"                        "item_blink_staff"\n        }\n    }\n')),Object(i.b)("p",null,'Notice how we added "02" to the item requirements and it only requires the item "item_blink_staff". This means we can combine our original blink staff to create fully new one with level set to its default value.',Object(i.b)("br",null),"Now what you should remember to do is change the description of the item and not keep the player guessing."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'        "DOTA_Tooltip_ability_item_blink_staff_Description"                               "Teleport to a target point up to 1200 units away. Can be used on allied units to select them to blink instead of you. If you take damage the Blink Staff is put on 3.0 second cooldown. Every time you help ally the help range is reduced by 500. This doesn\'t apply if used durring night time. You maximum mana is added to the help distance."\n')),Object(i.b)("h3",{id:"the-end"},"The End"),Object(i.b)("p",null,"That is end of this tutorial. If you have requests concerning this tutorial or improvements/corrections please comment bellow.",Object(i.b)("br",null),"\nYou can find this and other lua items and abilities from my Dota2Overflow github repo.",Object(i.b)("br",null),"\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/DrTeaSpoon/Dota2Overflow"}),"https://github.com/DrTeaSpoon/Dota2Overflow")),Object(i.b)("br",null),"To help declaring modifier functions use this for resource:",Object(i.b)("br",null),"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Lua_Abilities_and_Modifiers#Modifier_Functions",Object(i.b)("br",null),"Big thanks to BMD for barebones. While this tutorial has nothing to do with his repo, I used it for testing ground and creating the visual aids.",Object(i.b)("br",null),"Big thanks to all who have contributed to https://github.com/Pizzalol/SpellLibrary",Object(i.b)("br",null),Object(i.b)("p",null,"Happy Blinking!"),Object(i.b)(r.a,{id:"AthleticEminentAnnashummingbird",mdxType:"Gfycat"}))}u.isMDXComponent=!0},183:function(e,t,n){"use strict";var a=n(0),i=n.n(a),r=n(190),l=n(187),o=n(90),s=n.n(o);const c=37,u=39;t.a=function(e){const{block:t,children:n,defaultValue:o,values:f,groupId:h}=e,{tabGroupChoices:d,setTabGroupChoices:b}=Object(r.a)(),[g,m]=Object(a.useState)(o);if(null!=h){const e=d[h];null!=e&&e!==g&&f.some(t=>t.value===e)&&m(e)}const p=e=>{m(e),null!=h&&b(h,e)},_=[];return i.a.createElement("div",null,i.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(l.a)("tabs",{"tabs--block":t})},f.map(({value:e,label:t})=>i.a.createElement("li",{role:"tab",tabIndex:"0","aria-selected":g===e,className:Object(l.a)("tabs__item",s.a.tabItem,{"tabs__item--active":g===e}),key:e,ref:e=>_.push(e),onKeyDown:e=>((e,t,n)=>{switch(n.keyCode){case u:((e,t)=>{const n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()})(e,t);break;case c:((e,t)=>{const n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()})(e,t)}})(_,e.target,e),onFocus:()=>p(e),onClick:()=>p(e)},t))),i.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},a.Children.toArray(n).filter(e=>e.props.value===g)[0]))}},184:function(e,t,n){"use strict";var a=n(0),i=n.n(a);t.a=function(e){return i.a.createElement("div",null,e.children)}},185:function(e,t,n){"use strict";var a=n(0),i=n(34);t.a=function(){return Object(a.useContext)(i.a)}},186:function(e,t,n){"use strict";function a(e){return!1===/^(https?:|\/\/|mailto:|tel:)/.test(e)}n.d(t,"a",(function(){return a}))},187:function(e,t,n){"use strict";function a(e){var t,n,i="";if("string"==typeof e||"number"==typeof e)i+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(i&&(i+=" "),i+=n);else for(t in e)e[t]&&(i&&(i+=" "),i+=t);return i}t.a=function(){for(var e,t,n=0,i="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(i&&(i+=" "),i+=t);return i}},188:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));var a=n(185),i=n(186);function r(e,{forcePrependBaseUrl:t=!1,absolute:n=!1}={}){const{siteConfig:{baseUrl:r="/",url:l}={}}=Object(a.a)();if(!e)return e;if(t)return r+e;if(!Object(i.a)(e))return e;const o=r+e.replace(/^\//,"");return n?l+o:o}},189:function(e,t,n){"use strict";var a=n(0);const i=Object(a.createContext)({tabGroupChoices:{},setTabGroupChoices:()=>{},isAnnouncementBarClosed:!1,closeAnnouncementBar:()=>{}});t.a=i},190:function(e,t,n){"use strict";var a=n(0),i=n(189);t.a=function(){return Object(a.useContext)(i.a)}},191:function(e,t,n){"use strict";n.d(t,"a",(function(){return f})),n.d(t,"b",(function(){return b}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),u=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},f=function(e){var t=u(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),f=u(n),d=a,b=f["".concat(l,".").concat(d)]||f[d]||h[d]||r;return n?i.a.createElement(b,o(o({ref:t},c),{},{components:n})):i.a.createElement(b,o({ref:t},c))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var c=2;c<r;c++)l[c]=n[c];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},192:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));var a=n(0),i=n.n(a);function r({id:e,aspectRatio:t=4/3,hd:n="0"}){return i.a.createElement("p",{style:{position:"relative",paddingBottom:1/t*100+"%"}},i.a.createElement("iframe",{src:`https://gfycat.com/ifr/${e}?hd=${n}`,scrolling:"no",frameBorder:"0",allowFullScreen:!0,width:"100%",height:"100%",style:{position:"absolute",top:0,left:0}}))}},193:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));var a=n(0),i=n.n(a);function r({id:e,playlistId:t,aspectRatio:n=16/9}){const a=void 0!==t?"https://www.youtube.com/embed/videoseries?list="+t:"https://www.youtube.com/embed/"+e;return i.a.createElement("p",{style:{position:"relative",paddingBottom:1/n*100+"%"}},i.a.createElement("iframe",{src:a,frameBorder:"0",allowFullScreen:!0,width:"100%",height:"100%",style:{position:"absolute",top:0,left:0}}))}},194:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(3),i=n(184),r=n(183),l=n(0),o=n.n(l);const s={lua:"Lua",ts:"TypeScript",tsx:"TypeScript",js:"JavaScript",jsx:"JavaScript"};function c({children:e,group:t}){Object(a.a)("string"==typeof t||null===t);const n=o.a.Children.toArray(e).map(e=>{const t=e.props.children.props.className.replace(/language-/,"");return Object(a.a)(t in s),{language:t,element:e}});return o.a.createElement(r.a,{groupId:null!==t?"multi-code-block-"+t:void 0,defaultValue:n[0].language,values:n.map(({language:e})=>({value:e,label:s[e]}))},n.map(({language:e,element:t})=>o.a.createElement(i.a,{key:e,value:e},t)))}},195:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(188),i=n(0),r=n.n(i);function l({path:e,controls:t=!1}){return r.a.createElement("video",{width:"100%",height:"100%",autoPlay:!0,muted:!0,loop:!0,controls:t},r.a.createElement("source",{src:Object(a.a)(e),type:"video/mp4"}))}}}]);